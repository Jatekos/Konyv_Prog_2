<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>0.hét</title>
      
        <para>
          Python: Forstner Bertalan, Ekler Péter, Kelényi Imre: Bevezetés a mobilprogramozásba.
      Gyors prototípus-fejlesztés Python és Java nyelven (35-51 oldal)
        </para>
        <para>
           Általános információk: A Python egy általános célú programozási nyelv. Guido van Rossum 1990-ben
      alkotta meg ezt a fejlesztők számára rengeteg pozitív tulajdonsággal rendelkező nyelvet, amely magas
      szintű, dinamikus, objektumorientált és platform- független. A fejlesztés megkönnyítéséhez magas szintű
      típusokat is támogat, mint például különféle listák és szótárak.
      Előnyei miatt az interpreter elkészítették a Symbian mobil operációs rendszer S60 platformja alá is, hogy
      megkönnyítsék az egyszerűbb szoftver és prototípusfejlesztést mobil készülékekre. A Python S60 implementáció
      nagy- részt lefedi az alap Pythont, azonban egy-két modult kihagytak belőle, amely nem kapcsolódik
      szorosan a mobileszközökhöz.
      A Python nyelv jellemzői Amikor alkalmazásokat fejlesztünk, sok esetben szükség van olyan részek megírására
      is, amelyek az adott probléma szempontjából nem relevánsak, el- készítésük mégis sok időt vesz
      igénybe. Ilyenek például a különféle fájlkezelő metódusok, hálózatkezelés, GUI kialakítása stb. A szokásos
      programírás/fordítás/tesztelés/újra fordítás ciklust egy professzionális C, C++ vagy Java-fejlesztő is
      lassúnak találja egy idő után, márpedig erre minden módosítás esetében szükség van. A Python ebben is
      segít, esetében ugyanis nincs szükség a fordítás fázisára, az értelmezőnek elegendő a Python- forr
      A Python nyelv legfőbb jellemzője, hogy behúzásalapú a szintaxisa. A prog- ramban szerepl˝o állításokat
      az azonos szint˝u behúzásokkal tudjuk csoportok- ba szervezni, nincs szükség kapcsos zárójelre vagy explicit
      kulcsszavakra (pl. begin, end). Egy adott blokk végét egy kisebb behúzású sor jelzi, tehát például
      üres sor lehet a blokkon belül. A szkript els˝o utasítása nem lehet behúzott. Fontos, hogy a behúzásokat
      egységesen kezeljük, tehát vagy mindenhol tabot, vagy egységesen szóközt használjuk. Bizonyos szövegszerkeszt
      ˝okben akár azt is beállíthatjuk, hogy a tab billenty˝u lenyomása 4 szóközt jelentsen. A nyelv
      további sajátossága, hogy a sor végéig tart egy utášítás, nincs szükség a megszokott ;’ használatára.
      Pythonban minden adatot objektumok reprezentálnak. Az adatokon végezhe- t˝o m˝uveleteket az objektum
      típusa határozza meg. Pythonban nincs szükség a változók típusainak explicit megadására, a rendszer 
      futási id˝oben, automa- tikusan „kitalálja" a változók típusát a hozzárendelt érték alapján. Az adattípusok a
      következ˝ok lehetnek: számok, sztringek, ennesek (tuples, n-es), listák, szótárak (dictionaries).
      Változók és alkalmazásuk Pythonban a változók alatt az egyes objektumokra mutató referenciákat ér- tünk.
      Maguknak a változóknak nincsenek típusai, így egy szkript futása so- rán bármely, akár különböz˝o típusú
      objektumra is hivatkozhatnak. Ameny- nyiben egy objektumra az utolsó hivatkozást is töröljük (pl. a változói
      már más objektumokra mutatnak), az automatikus garbage collector szabadítja fel a memóriaterületet.
      A nem létez˝o változókra való hivatkozás futás közbeni kivételt okoz.
      Pythonban függvényeket a def kulcsszóval definiálhatunk. A függvényekre mint értékekre is tekinthetünk,
      hiszen azok továbbadhatók más függvények- nek, illetve objektumkonstruktoroknak is. A függvények
      rendelkeznek para- méterekkel, amelyeknek, a szokásos megkötésekkel és szintaxissal, alapér- telmezett
      értéket is adhatunk. A paraméterek érték szerint adódnak át, kivé- ve az úgynevezett mutable típusok (pl.
      listák, szótárak), amelyek függvénybe- li megváltoztatása hatással van a hívókódrészletben lév˝o objektumra
      is. Az egyes paramétereknek a szokásos szintaxissal (paraméter értelmezett értéket is adhatunk.
      A Python nyelv támogatja a klasszikus, objektumorientált fejlesztési eljárá- sokat, amelyeket ebben az
      alfejezetben röviden átnézünk. Definiálhatunk osztályokat, amelyek példányai az objektumok. Az osztályoknak
      lehetnek att- ribútumaik: objektumok, illetve függvények. Ez utóbbiakat metódusoknak vagy
      tagfüggvénynek is hívjuk. Ezenkívül az osztályok örökölhetnek más osz- tályokból is.
        </para>

      <para>
        Összehasonlítás c++ java:
      </para>
      
      <para>
        kifejezés fogalom ua.:Kifejezések olyan kód részletek amelyek valami műveletet végeznek és a művelet eredményét adják vissza, vagy pedig valami értéket reprezentálnak.
        ,
        stb:Java esetén egy osztály definíciója és deklarációja,azaz az eljárások feje és megvalósítása nem szétválasztható, mint például C++-ban.
        Ahogy C++-ban, úgy a Javában is felsorolhatunk változókat,de a Java megengedi, hogy inicializáljuk is azokat,konstruktoron kívül
        konstruktor: Ennek neve – ahogy C++-ban is – megegyezik az osztály nevével, nincs visszatérési értéke.
        final: Végleges, azaz konstans érték (nem ugyanaz mint a C++ const! Hiszen itt a referencia az az érték, ami nem változtatható, de ettől még a hivatkozott objektum állapota változtatható)
        Javában minden metódus olyan, mint C++-ban a virtual kulcsszóval ellátottak.Itt a dinamikus kötés automatikusan létrejön! Ha a metódus az osztályban nem static jelzővel illetett, akkor nincs olyan momentum, amely egyértelműen az alaposztályához kötné (azaz példánymetódus). A kötés ekkor csakis dinamikus lehet, ami azért érdekes helyzet, mert előre senki sem tudhatja (legfőképpen a JVM nem), hogy éppen melyik példánymetódus fut, azaz a kötés csakis a futási idő alatt jöhet létre. Ezért illetik egyúttal a dinamikus kötést a következő jelzőkkel:futás alatti kötés:runtime binding,
        ,késői kötés - late binding, illetve dinamikus kötés alatti példánymetódus-keresés folyamatát dinamikus metóduskeresésnek (dynamic method lookup). A keresés végeredménye ebben az esetben csakis az lehet, hogy az éppen aktuálisan futó objektum kerül végrehajtásra. c++ ehhez a virtual jelzőt kell használni
        Javában minden objektum:referencia:
        klónozás
        A java a c++-al ellentétben platform független mivel egy virtuális gépen fut ez a JVM és JRE ezen felül van a JDK ami már a java programok fejélesztéséhez szükséges. Ebből következik, hogy a java programoknak rosszabb az optimalizáltságga  a c+++ hoz képes amit a fordító programok gépi nyelvre fordítanak de szintén ebből következik hogy könnyebben hordozhatók és biztonságosabbak a java programok.

        C++ elsősorban rendszerprogramozásra használják míg A javat alkalmazások fejlesztésére. Széleskörben használják webes, mobilos alkalmazások fejlesztésére. Ennek fő okai a könnyű egységekre bontás és tagolása a programoknak.

        Goto utasítás a c6+ támogatja de a java nem . (de alapvetően egy jól struktúrát programban nincs is szükség a goto utasítás használatára)

        A c++ támogatja a többszörös öröklődést míg a java nem támogatja a többszörös öröklődést osztályok között.DE az interfacek használatával a jávában is át hidalható ez a probléma

        Az operátor túlterhelést nem támogatja a java a c++-al szemben ahol ez egy bevet metódus a javaban külön függvények segítségével oldható fel ez a probléma.,

        Míg c++ teljesen támogatja a pointerek felhasználását a programokban addig a java csak belsőleg támogatja őket nem írható mutatókat explicite használó program.
        Ez azt jelenti, hogy a java korlátozta a mutató támogatását

        C++ ban mind érték mind referencia alapján lehet hívni addig java nem támogatja a referencia alapú hívást csak érték alapú hívások vannak a jávában.

        A java mindig egy öröklődési fát tartalmaz mert minden osztály az Object class gyermeke. A jávában mindig az Object Class a gyökere az öröklődési fának. Ezzel szemben a c++ mindig új öröklődési fát készít.
        A jdk JRE JVM felépitéséből adódóan a Java nem lép kapcsolatba közvetlenül a hardwarerel míg a c++ fordítási metódusából adódóan az abban írt programok igen.

      </para>
      
       
    </section>        

    <section>
        <title>1.hét</title>
        <para>
            Eljárás orientál vs Objektumorientált
        </para>
        <para>
          
Elsőként tisztázzuk a két fogalmat. Az eljárás orientált nyelvek alatt azokat értjük melyek struktúrát programozási elvek alapján működnek, mely eljárás híváson alapszik. Ezek az eljárások a program során bármikor meg hívhatóak, akár saját magukat is hívhatják. A feladatokat lépésről lépésre bontja le az eljárás orientált program változókra és eljárásokra melyek szekvenciális utasításokat tartalmaznak. Ezzel szemben az Objektumorientált nyelvek az objektumokon alapszanak melyeknek vannak tulajdonságuk és viselkedésük melyekkel képesek megváltoztatni a saját és más objektumok tulajdonságait.
Az elmondható mind két paradigmáról, hogy kisebrészekre bontják fel a problémát ezen keresztül pedig a kódot is. A nagy különbség a kettő féle felbontásban az hogy az objektumorientáltnál sokall könnyebb utólagosan változtatni a programon egy jól meg tervezet programnál csak az adott objektumon kel választani. Míg az eljárás orientáltnál mivel az egész egy programként kezelődik így az egész program változik. Ebből következik az is, hogy az objektumorientált programok sokkal modulárisabbak egyes modulokat akár több programnál is fel lehet használni ezáltal és az által, hogy jobban tagolható az írása rövidül a fejlesztési idő is.
Objektumorientált nyelvekben lehet szabályozni a láthatóságot (public, private, protected) mely segítségével elrejthetők az adatok ezáltal biztonságosabb mint az eljárásorientált nyelvek ahol erre nincs lehetőség.
Az objektum orientált nyelveknél könnyebb bővítés az öröklődésnek köszönhetően. Erre az eljárás orientált nyelveknél nincs lehetőség.
        </para>
        <para>
           Java Object metódusok :              
        </para>
        <para>
            protected Object clone(): Vissza tér egy másolatával az adott objektumnak. x.clone() != x igazat fog adni, x.clone().equals(x) igazat fog adni de ez nem elvárás a használathoz felül kel definiálni a protected miatt nem látszik.
        </para>
    <para>
            Boolean equals​(Object obj) : megalapítja hogy egy objectum egyenlő-e azzal amelyből hívjuk. Abban az esetben kell felüldefiniálni ezt a  metódust ha az adott objektum más objektumot is tartalmaz mer ebben az esetben az objektum == operátorral hasonlítja össze és így csak akkor ad igazat ha ugyan arra a helyre mutatnak. Abban az esetben ha felül definiáljuk a  equals() metódust a hasCode() metódust is illik felüldefiniálni mivel az egyenlő objectumoknak ugyan annak kell lenije a has kódjának.
        </para>
          <para>
            Class  getClass() Visszatér az osztállyal futás időben mellyel különböző információkat nyerhetünk ki az osztályról.
        </para>
        <para>
            Int hashCode() Vissza tér egy has értékel az objektumra.
Egy futtatás alatt egy adott objektumnak nem szabad változnia a has kódjának de futások között már változhat
ha két objectom egyenlő az  equals(Object) metódus alapján akkor ugyan azt a has értéket kell hogy kapják
az nem elvárás ha két objektum különbözik akkor külön hash kódot kapjanak
        </para>
        <para>
            Void notify() Egyetlen szálat ébreszt fel, amely az objektum monitorára vár. Az felébresztett szál addig nem folytatódik, amíg az aktuális szál nem oldja fel az objektum zárolását csak az objektum „gazdája” adhatja ki ezt az utasítást. A fel ébresztett szál nem élvez semmilyen előjogot az objektumra
        </para>
        <para>
            Void notifyAll() Minden szálat  fel ébreszt , amely az objektum monitorára vár. A fel ébresztett szálak nem élveznek semmilyen előjogot az objektumra
        </para>
        <para>
            String toString()	 Egy stringgle tér vissza ami meg adja az objektumot érdemes felül definiálni alapértelmezetten ezt a kifejezést adja vissza: getClass().getName() + '@' + Integer.toHexString(hashCode())
        </para>
  <para>
            Void wait() A aktuális szál várását eredményezi míg fel nem ébresztik,vagy meg nem szakítják.
        </para>
     <para>
            Void wait​(long timeout, int nanos)  aktuális szál várását eredményezi míg fel nem ébresztik,vagy meg nem szakítják vagy el nem telik a meg adott idő
        </para>
      
    <para>
      Singleton Design Pattern:
      </para>
      <para>
Biztosítani kel, hogy csak egy objektum jöhessen létre az adott osztályból, ezt az objektumot mindenkinek el kel érnie. Ez azzal jár, hogy a lazán kell iniciálni az adott objektumot. 
Előállítása: összes konstruktort felül kell definiálni egy protecteddel vagy private függvénnyel és kel egy statikus függvény ami hívja a konstruktort ha még nem létezik az adott objektum
Akkor érdemes használni ha egy objektumból pontosan egy darab kell pl.:facade objestc,State object.
</para><para>
Abstract Factory Design Pattern
</para><para>
A lényege a Abstract Factory-nek hogy interfacet adjon ahhoz hogy családokat hozzunk létre összetartozó objektumokból. A japán autó gyártásban használt modellt modellezi ahol egy prés
kis változásokkal képes több típus adott elemét elő állítani. A programozásban a hordozhatóságra ad egy megoldást ahol az adott rendszerhez kell alkalmazkodni de ez sok #ifdef részel járhat a programban.(sokszor használ singletont az egyes objektumok hoz)
</para><para>
Builder Design Pattern
</para><para>
El választja az elkészítését egy összetett objektumnak a reprezentációjától és ezzel eléri, hogy ez az eljárás képes legyen különböző  reprezentációkat el készíteni. 
</para><para>
Factory Method Design Pattern:
</para><para>
Meg ad egy felületet egy objektum létrehozásához, de hagyja, hogy az alosztályok döntsék el, melyik osztályt kell példányosítani.
A Factory Method lehetővé teszi, hogy az osztály megengedi az alosztályok példányosítását. Definiál egy virtuális konstruktort. A new operátor ártalmas lehet.
</para><para>
Object Pool Design Pattern
</para><para>
Az object pool jelentős teljesítménynövekedést kínálhat; leghatékonyabb azokban a helyzetekben, amikor az osztálypéldány inicializálásának költsége magas, az osztály példányosítási aránya magas, és az egyszerre használt példányszám alacsony.
Az Object Pool (más néven erőforráskészletek) az objektum-gyorsítótár kezelésére szolgálnak. Az Objektumkészlethez hozzáférő kliens elkerülheti az új Objektumok létrehozását, ha egyszerűen megkéri a készletet hogy adjon egy már példányosítottat. Általában a pool növekvő medence lesz, vagyis maga a pool új objektumokat hoz létre, ha a pool üres, vagy rendelkezhetünk pool-lal, ami korlátozza a létrehozott objektumok számát.
</para><para>
Prototype Design Pattern
</para><para>
létre hoz egy objektumot majd ezt az objektumot módosítja és clonozza ehez használnia kell a clone abel interfészt .  A new operátor káros. Egy objektum az őse minden objekumnak
    </para>

      <para>
        OO szemlélet
      </para>
      <para>
        C++ ban:
      </para>
      <programlisting language="c++">
        <![CDATA[
#include <iostream>
#include <cstdlib>
#include <cmath>
#include <ctime>

class ElsoOsztajom
{
private:
    bool letezikKovVeletlen;
    double kovVeletlen;
public:
    ElsoOsztajom();
    ~ElsoOsztajom();

    double veletlen();
};

ElsoOsztajom::ElsoOsztajom()
{
    letezikKovVeletlen=false;
}

ElsoOsztajom::~ElsoOsztajom()
{
}

double ElsoOsztajom::veletlen()
{
    if (letezikKovVeletlen)
    {
        letezikKovVeletlen =false;
        return kovVeletlen;
    }
    else
    {
        double u1, u2, v1, v2, w;
        do 
        {
            u1=std::rand()/(RAND_MAX+1.0);
            u2=std::rand()/(RAND_MAX+1.0);
            v1=2*u1-1;
            v2=2*u2-1;
            w=v1*v1+v2*v2;
        }
        while (w>1);
        double r =std::sqrt((-2*std::log(w))/w);
        
        kovVeletlen=r*v2;
        letezikKovVeletlen =true;
        
        return r*v1;
    }
    

}

int main(){
    double j=0;
    ElsoOsztajom r;
    for (int i=0; i<5; i++)
    {
        j=r.veletlen();
        std::cout<<j<<std::endl;
    }
   
}]]>
      </programlisting>


      <para>
        Javaban:
      </para>
      <programlisting language="c++">
        <![CDATA[
PolarGenerator:
        
package ooszemlelet;

import java.lang.Math;

public class PolarGenerator {
	
	private boolean isStored = false;
	private double stord;
	
	public double giveTheNext() {
		
		if (isStored) {
			
			isStored = !isStored;
			return stord; 
			
			
		} else {
			
			double u1, u2, v1, v2 ,w;
			
			do {				
				u1 = Math.random();
				u2 = Math.random();
				v1 = 2 * u1 - 1;
				v2 = 2 * u2 - 1;
				w = v1 * v1 + v2 * v2;				
			}
			while (w>1);
			
			double r =Math.sqrt((-2 * Math.log(w)) / w);
			stord=r * v2;
			isStored = !isStored;
			return r*v1;
						
		}
	}
	
	
	
}


Main:

package ooszemlelet;



public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		PolarGenerator g = new PolarGenerator();
		for (int i=0; i<10 ; i++) {
			System.out.println(g.giveTheNext());
		}

	}

}

]]>
      </programlisting>


    </section>
    <section>
        <title>2.hét</title>
        <para>EPAM:Interfész evolúció Java ban</para>
        <para>A java 8 élőt csak abstract metódust lehetet az interfészekben használni. Minden
            metódus public és abstract alapból. A java 8 tól kezdve lehet default és static
            metódusokat is használni. A default metódus lehetővé teszi a fejlesztőnek hogy anélkül
            agyon hozza az iterface hez egy metódust hogy azzal befolyásolná azokat az osztályokat
            amelyek használják az adott interfacet. Ezt a tulajdonságot nevezhetjük vissza felé
            kompatibilitásnak is mivel ezzel a képességet ki használva egy létező kódba tudunk új
            funkciót belerakni anélkül hogy tönkretennék a már létező kódot vagy teljesen újra
            kellene írnunk. A staticus metódusok hasonlóan viselkednek a default metódusokhoz azzal
            a különbséggel hogy ezeket a metódusokat nem lehet felülírni az osztályokban. Ez a két új
            funkció felveti a többszörös öröklődés kérdését is, ha van két interface amiben van egy
            egy ugyan olyan nevű metódus és egy osztály egyszere implementálja mind két interfacet nem
            lehet eldönteni hogy melyik metódus futsonle. Erre egy megoldás ha az ilyen metódusokat
            felül definiáljuk</para>
        <para>EPAM:Liskov féle helyettesíthetőség elve, öröklődés</para>
        <para>osztály definiciók:</para>
        <programlisting> public class Vehicle {

    public Vehicle() {
        System.out.println("Creating vehicle!");
    }

    void start() {
        System.out.println("Vehicle is starting!");
    }

}
 </programlisting>
        <programlisting>  public class Car extends Vehicle {
     
    public Car() {
        System.out.println("Creating car!");
    }

    @Override
    void start() {
        System.out.println("Car is starting!");
    }

}
</programlisting>
        <programlisting> package com.epam.training;

public class Supercar extends Car {

    public Supercar() {
        System.out.println("Creating supercar!");
    }

    @Override
    void start() {
        System.out.println("Supercar is starting!");
    }

}
 </programlisting>
        <para>tesztelése:</para>
        <programlisting>Vehicle firstVehicle = new Supercar();
firstVehicle.start();
System.out.println(firstVehicle instanceof Car);
</programlisting>
        <para>kimenet:</para>
        <programlisting>Creating vehicle!
Creating car!
Creating supercar!
Supercar is starting!
true</programlisting>
        <para>A firstVehicle létrehozásánál mivel Supercar-ból let létre hozva ezért lefut a
            Vehicle a Car és a Supercar construktora is de mivel a firstVehicle  Car tipusu így csak
            a Car metódusait éri el.</para>
        <programlisting>Car secondVehicle = (Car) firstVehicle;
secondVehicle.start();
System.out.println(secondVehicle instanceof Supercar);

System.out.println(firstVehicle.toString());
System.out.println(secondVehicle.toString());</programlisting>
        <para>kimenet:</para>
        <programlisting>Supercar is starting!
true
com.epam.training.Supercar@25618e91
com.epam.training.Supercar@25618e91</programlisting>
        <para>Az érték adásnál Car-t adunk árt Car-nak de mivel az átadot Car egy Supercar volt így
            átadás után is az marad mert csak a címét adta át az objektumnak. </para>
        <programlisting>
Supercar thirdVehicle = new Vehicle();
thirdVehicle.start();</programlisting>
        <para>Itt mivel a Supercar bőveb mint a Vehicle nem tudja belőle létrehozni .</para>
        <para>EPAM: Interfész, Osztály, Absztrak Osztály</para>
        <para>Az interfacekkel teljes szintű absztrakció valósítható meg míg a abstract osztállyal
            csak részleges absztrakció valósítható meg. Az interface egy tervrajzhoz hasonlítható míg
            az abstract class csak azt engedi meg hogy az eredeti class egyes részeit mi mondhatjuk
            meg hogy definiáljuk</para>
        <programlisting>package abstractClassClass;

public abstract class IntegerStorage {
	
	int [] storage;
	int numberOfElement;
	final int MAX_NUMBER_OF_ELEMENT=10;
	
	public IntegerStorage() {
		super();
		this.storage =  new int [MAX_NUMBER_OF_ELEMENT];
		numberOfElement = -1;
	}
	
	abstract public void add(int value);
	abstract public int get();
	abstract public boolean contain(int value);


}
</programlisting>
        <programlisting>package abstractClassClass;

public class IntegerStorageFiFo extends IntegerStorage{

	@Override
	public void add(int value) {
		if (numberOfElement &lt;MAX_NUMBER_OF_ELEMENT) {
			numberOfElement++;
			storage[numberOfElement] = value;
		}
		
	}

	@Override
	public int get() {
		numberOfElement--;
		return storage[numberOfElement+1];
	}

	@Override
	public boolean contain(int value) {
		int i=0;
		while ((i&lt;=numberOfElement)&amp;&amp; (storage[i]!= value)) {
			i++;
		}
		
		if (i&lt;=numberOfElement) {
			return true;
		}else {
			return false;
		}
	}
	

}
</programlisting>
        <programlisting>package interfaceClass;

public interface IntegerStorage {

	public void add(int value);
	public int get();
	public boolean contain(int value);
	
}
</programlisting>
        <programlisting>package interfaceClass;

public class IntegerStorageFiFo implements IntegerStorage {

	int [] storage;
	int numberOfElement;
	final int MAX_NUMBER_OF_ELEMENT=10;
	
	public IntegerStorageFiFo() {
		super();
		this.storage =  new int [MAX_NUMBER_OF_ELEMENT];
		numberOfElement = -1;
	}

	public void add(int value) {
		
		if (numberOfElement &lt;MAX_NUMBER_OF_ELEMENT) {
			numberOfElement++;
			storage[numberOfElement] = value;
		}
		
	}

	public int get() {
		numberOfElement--;
		return storage[numberOfElement+1];
	}

	public boolean contain(int value) {
		int i=0;
		while ((i&lt;=numberOfElement)&amp;&amp; (storage[i]!= value)) {
			i++;
		}
		
		if (i&lt;=numberOfElement) {
			return true;
		}else {
			return false;
		}
	}
 
}
</programlisting>
        <para>A példában bemutat kódban az abstrac class nál meg adjuk hogy milyen adat szerkezetet
            használunk de azt nem hogy ezzel hogyan dolgozunk, míg az interface nél ezt se adtuk meg
            teljesen független tőle csak azt adtuk meg hogy milyen metódusokat használjon. Az
            abstrakció szintjétől/igényétől függ hogy melyiket érdemes használni. Ha pedig egyáltalán
            nics absztrakcióra szükség akkor érdemes Class-t használni. Az interfacek e mellet arra
            is jók hogy egy azt implikáló osztályt tudjunk használni annak a belső működése ismerete
            nélkül. Ez elő segíti program kód tagolását is.</para>
    </section>
    <section>
        <title>3.hét</title>
        <para>EPAM: Neptun tantárgyfelvétel modellezése UML ben</para>
        <para><inlinemediaobject>
                <imageobject>
                    <imagedata fileref="./Targyfelveteluml.png"/>
                </imageobject>
            </inlinemediaobject></para>
        <para>EPAM: Neptun tantárgyfelvétel UML diagram implementálása</para>
        <para>Abstract class NeptunEntity</para>
        <para>Azt az osztályt azért hoztam létre mert voltak azonos attribútumaik a Student-nek és a
            Lessen-nek</para>
        <programlisting>package targyfelvetel;

public abstract class NeptunEntity {
	protected String neptunCode;
	protected String name;
	
	
	
	
	public NeptunEntity(String neptunCode, String name) {
		super();
		this.neptunCode = neptunCode;
		this.name = name;
	}
	protected String getNeptunCode() {
		return neptunCode;
	}
	protected void setNeptunCode(String neptunCode) {
		this.neptunCode = neptunCode;
	}
	protected String getName() {
		return name;
	}
	protected void setName(String name) {
		this.name = name;
	}
	
	
}
</programlisting>
        <para>Lessen class felelős az órák ért azoknak az adatainak a tárolásáért és
            beállításaiért</para>
        <programlisting>package targyfelvetel;

import java.util.Map;

public class Lessen extends NeptunEntity{
	
	boolean takeAble;
	int maxNumberStudent;
	int currentNumberOfStudent;
	//TODO linkidmap cserélni map re 
	
	private Lessen(String neptunCode, String name, int maxNumberStudent) {
		super(neptunCode, name);
		this.takeAble = true;
		this.maxNumberStudent = maxNumberStudent;
		this.currentNumberOfStudent = 0;
	}
	
	static public void getANewLessen(Map&lt;String, Lessen>lessens,String neptunCode, String name, int maxNumberStudent) {
		
		Lessen curentLessen=new Lessen(neptunCode, name, maxNumberStudent);
		lessens.put(neptunCode, curentLessen);
	}


	public boolean isTakeAble() {
		return takeAble;
	}


	public void setTakeAble(boolean takeAble) {
		this.takeAble = takeAble;
	}


	public int getMaxNumberStudent() {
		return maxNumberStudent;
	}


	public void setMaxNumberStudent(int maxNumberStudent) {
		this.maxNumberStudent = maxNumberStudent;
	}


	public int getCurrentNumberOfStudent() {
		return currentNumberOfStudent;
	}
	
	public boolean chekTakeAble() {
		if (currentNumberOfStudent&lt;maxNumberStudent) {
			setTakeAble(true);
			return true;
		}else {
			setTakeAble(false);
			return(false);
		}
	}
	
	public void incrementCurrentNumberOfStudent() {
		this.currentNumberOfStudent++;
	}


	public void setCurrentNumberOfStudent(int currentNumberOfStudent) {
		this.currentNumberOfStudent = currentNumberOfStudent;
	}
	
	
	
}
</programlisting>
        <para>Student class képes tárgyat felvenni (ezáltal változást is tud okozni a Lessen-ben ez
            felvethet némi problémát)</para>
        <programlisting>package targyfelvetel;

import java.util.Map;

public class Student extends NeptunEntity {
	
	
	LinkidMap&lt;Integer,String >takenLessen;
	int numberOfTakenLessen;
	
	private Student(String neptunCode, String name) {
		super(neptunCode, name);
		this.takenLessen = new LinkidMap&lt;>();
		numberOfTakenLessen =0;
	}
	
	public static Student getANewStudent(String neptunCode, String name) {
		Student currentStudent =new Student(neptunCode, name);
		return currentStudent;
	}


	public  String takeLesson(Map&lt;String,Lessen> lessens,String lesenCode) {
		
		if (lessens.containsKey(lesenCode)) {
			Lessen currentLessen;
			currentLessen=lessens.get(lesenCode);
			if (currentLessen.chekTakeAble()) {
				setNumberOfTakenLessen(getNumberOfTakenLessen()+1);
				currentLessen.incrementCurrentNumberOfStudent();
				takenLessen.put(this.numberOfTakenLessen, lesenCode);
				return lesenCode;
			}
		}
		
		
		return null;
	}


	public LinkidMap&lt;Integer, String> getTakenLessen() {
		return takenLessen;
	}


	public void setTakenLessen(LinkidMap&lt;Integer, String> takenLessen) {
		this.takenLessen = takenLessen;
	}


	public int getNumberOfTakenLessen() {
		return numberOfTakenLessen;
	}


	public void setNumberOfTakenLessen(int numberOfTakenLessen) {
		this.numberOfTakenLessen = numberOfTakenLessen;
	}
	
	

}
</programlisting>
        <para>A neptun class ban vannak tárolva az órák és a hallgatók és itt tudjuk őket létre
            hozzni</para>
        <programlisting>package targyfelvetel;

public class Neptun {

		LinkidMap&lt;String, Lessen> lessens = new LinkidMap&lt;>();
		LinkidMap&lt;String, Student> students = new LinkidMap&lt;String, Student>();
		
		public Neptun() {
			
			
		}
		
		public void AddAStudent(String neptunCode,String name) {
			students.put(neptunCode,Student.getANewStudent( neptunCode, name));
		}
		
		public void AddALessen(String neptunCode,String name, int maxNumberStudent) {
			Lessen.getANewLessen(lessens, neptunCode, name, maxNumberStudent);
		}
		
}
</programlisting>
        <para>EPAM:OO modellezés</para>
        <para>SOLID</para>
        <itemizedlist>
            <listitem>
                <para>Single-responsibility principle</para>
                <para>Egy osztálynak csak egyetlen felelőssége kell, hogy legyen, vagyis a szoftver
                    specifikációjának csak egy részén végzett változtatások befolyásolhatják az
                    osztály specifikációját. </para>
            </listitem>
            <listitem>
                <para>Open–closed principle</para>
                <para>A szoftvereknek nyitva kell lenniük a kiterjesztésre, de módosításra
                    bezárva.</para>
            </listitem>
            <listitem>
                <para>Liskov substitution principle</para>
                <para>Egy objektumot bármikor helyettesíthet egy all osztálya az adott
                    objektumnak</para>
            </listitem>
            <listitem>
                <para>Interface segregation principle</para>
                <para>Jobb mindenre külön külön interface csinálni ,mint egy univerzálisat
                    használni</para>
            </listitem>
            <listitem>
                <para>Dependency inversion principle</para>
                <para>Az absztrakciónak kell az alapját szolgálnia a programoknak nem konkréttan
                    megírt kódok</para>
            </listitem>
        </itemizedlist>
        <para>KISS</para>
        <para>A KISS (keep it stupid simple/keep it simple, soldier) elv szerint a legtöbb rendszer
            akkor működik a legjobban, ha egyszerűbbé teszik, nem pedig bonyolulttá teszik őket;
            ezért a tervezésnél az egyszerűségnek kell kulcsfontosságúnak lennie, és kerülni kell a
            felesleges bonyolítást.</para>
        <para>DRY</para>
        <para>Don't repeat yourself</para>
        <para>Minden információnak egy elfordulásának kell hogy legyen a rendszerben (kétszer ugyan
            azt a a kódot felesleges megírni csak hibaforrás lesz)</para>
        <para>YAGIN</para>
        <para>You ain't gonna need it</para>
        <para> Addig nem kell létre hozni egy függvény míg nincs rá szükséged még akkor se ha azt
            sejted hogy szükséged lesz rá</para>
    </section>
    <section>
        <title>4.hét</title>
        <para>EPAM: Order of everything</para>
		<programlisting>package com.epam.training;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

/**
 * # Order of everything
 *
 * Collection-ok rendezĂ©se esetĂ©n jellemzĹ‘en futĂˇsi idĹ‘ben derĂĽl ki,
 * ha olyan tĂ­pusĂş objektumokat prĂłbĂˇlunk rendezni, amelyeken az Ă¶sszehasonlĂ­tĂˇs
 * nem Ă©rtelmezett (azaz `T` tĂ­pus esetĂ©n nem implementĂˇljĂˇk a `Comparable&lt;T>` interface-t).
 * Pl. ClassCastException a [Collections.sort()](https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#sort(java.util.List)) esetĂ©ben,
 * vagy ClassCastException a [Stream.sorted()](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#sorted--) esetĂ©ben.
 *
 * ĂŤrj olyan metĂłdust, amely tetszĹ‘leges Collection esetĂ©n vissza adja az elemeket
 * egy List-ben nĂ¶vekvĹ‘en rendezve, amennyiben az elemek Ă¶sszehasonlĂ­thatĂłak velĂĽk azonos tĂ­pusĂş objektumokkal.
 * Ha ez a feltĂ©tel nem teljesĂĽl, az eredmĂ©nyezzen syntax error-t.
 *
 * PĂ©ldĂˇul:
 * ```
 *     List&lt;Integer> actualOutput = createOrderedList(input);
 * ```
 * Ahol az `input` `Collection&lt;Integer>` tĂ­pusĂş. TermĂ©szetesen mĂˇs tĂ­pusokkal is mĹ±kĂ¶dnie kell,
 * feltĂ©ve, hogy implementĂˇljĂˇk a Comparable interface-t.
 */
public class OrderOfEverythingTest {

    @Test(dataProvider = "collectionsToSortDataProvider")
    public void testOrderShouldReturnExpectedListWhenCollectionIsPassed(Collection&lt;Integer> input, List&lt;Integer> expectedOutput) {
        // Given as parameters

        // When
        // createOrderedList(List.of(new OrderOfEverythingTest()));
        // ^ ez piros, az OrderOfEverythingTest nem implementĂˇlja a Comparable&lt;OrderOfEverythingTest> -et
        List&lt;Integer> actualOutput = createOrderedList(input);

        // Then
        assertThat(actualOutput, equalTo(expectedOutput));
    }

    @DataProvider
    private Object[][] collectionsToSortDataProvider() {
        return new Object[][] {
            {Collections.emptySet(), Collections.emptyList()},
            {Set.of(1), List.of(1)},
            {Set.of(2,1), List.of(1,2)}
        };
    }

    private &lt;T extends Comparable&lt;T>> List&lt;T> createOrderedList(Collection&lt;T> input) {
        return input.stream()
            .sorted()
            .collect(Collectors.toList());
    }
}
</programlisting>
        <para>EPAM: Bináris keresés és Buborék rendezés
            implementálása<programlisting>package IntegerStorage;

import java.util.Arrays;

public class IntegerStorage {
	private int[] storage;
	private int index = 0;

	public IntegerStorage(int size) {
		super();
		this.storage = new int[size];
	}
	
	public IntegerStorage(int[] storage) {
		super();
		this.storage = storage;
		this.index=storage.length;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.hashCode(storage);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		IntegerStorage other = (IntegerStorage) obj;
		if (!Arrays.equals(storage, other.storage))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return "IntegerStorage [storage=" + Arrays.toString(storage) + "]";
	}
	
	public void add(Integer value) {
		storage[index++]=value;
	}

	
	public boolean contains(Integer value) {
		int l=0;
		int r=index;
		
		while ((r>=l) &amp;&amp; (value!=storage[(r+l)/2])) {
			if (value&lt;storage[(r+l)/2]) {
				r=(l+r)/2;
			}else {
				l=(l+r)/2;
			}
		}
		
		if (r>=l) {
			return true;
		}else {
			return false;
		}			
	}
	
	public int[] sort() {
		
		for(int i=0; i&lt;index-1; i++) {
			for(int j=i+1; j&lt;index; j++) {
				if (storage[i]>storage[j]) { 
					int s;
					s=storage[j];
					storage[j]=storage[i];
					storage[i]=s;
					
				}
			}
		}
		return storage;
	}

}
</programlisting></para>
        <para>EPAM: Saját HashMap implementáció</para>
        <para>Egy Hash map kialakításához egty ArrayList-et használtam melybe Map-eket hoztam létre
            (ez a saját magam által meg írt linkedmap volt)ez álltan láncolt listával oldom meg az
            ugyan olyan hash kódú elemek tárolását de igazából a HashMap szempontjából/működéséből
            következően annak nincs jelentősége hogy milyen mappal lesz ez megoldva.</para>
        <programlisting>package sajatHasMap;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;



public class HashMap2&lt;K,V> implements Map&lt;K, V> {

	private final int  PRIME=7;
	ArrayList&lt;LinkidMap&lt;K,V>> rows;
	int size;
	
	private int hash(Object key) {
		int result;
		result =key.hashCode() % PRIME;
		
		return result; 
	}
	
	
	
	
	
	public HashMap2() {
		super();
		this.rows = new ArrayList&lt;LinkidMap&lt;K,V>>(PRIME);
		for(int index=0; index&lt;PRIME; index++) {
			rows.add(new LinkidMap&lt;K,V>());
		}
		this.size = 0;
	}





	@Override
	public int size() {
		// TODO Auto-generated method stub
		size=0;
		for(int index=0; index&lt;PRIME; index++) {
			size+=rows.get(index).size();
		}
		return size;
	}

	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		
		for (int index=0; index&lt;PRIME; index++) {
			if(! rows.get(index).isEmpty())
				return false;
		}
		
		return true; 
	}

	@Override
	public boolean containsKey(Object key) {
		// TODO Auto-generated method stub
		
		int index= hash(key);
		return rows.get(index).containsKey(key);
	
	}

	@Override
	public boolean containsValue(Object value) {
		// TODO Auto-generated method stub
		for(int index=0; index&lt;PRIME;index++) 
			if (rows.get(index).containsValue(value))
				return true;
		return false;
	}

	@Override
	public V get(Object key) {
		// TODO Auto-generated method stub
		int index= hash(key);
		return rows.get(index).get(key);
	}

	@Override
	public V put(K key, V value) {
		// TODO Auto-generated method stub
		int index= hash(key);
		return rows.get(index).put(key, value);
	}

	@Override
	public V remove(Object key) {
		// TODO Auto-generated method stub
		int index= hash(key);
		return rows.get(index).remove(key);
	}

	@Override
	public void putAll(Map&lt;? extends K, ? extends V> m) {
		// TODO Auto-generated method stub
		Set&lt;? extends K> keys = m.keySet();	
		for ( K key:keys) {
			this.put(key, m.get(key));			
		}
		
	}

	@Override
	public void clear() {
		// TODO Auto-generated method stub
		for (int index=0; index&lt;PRIME; index++)
			rows.get(index).clear();
	}

	@Override
	public Set&lt;K> keySet() {
		// TODO Auto-generated method stub
		Set&lt;K> keys =  new HashSet&lt;K>();
		for (int index=0; index&lt;PRIME; index++)
			keys.addAll(rows.get(index).keySet());
		return keys;
	}

	@Override
	public Collection&lt;V> values() {
		// TODO Auto-generated method stub
		Collection&lt;V> collection =new ArrayList&lt;>();
		for (int index=0; index&lt;PRIME; index++)
			collection.addAll(rows.get(index).values());
		return collection;
	}

	@Override
	public Set&lt;Entry&lt;K, V>> entrySet() {
		// TODO Auto-generated method stub
		Set&lt;Entry&lt;K, V>> result = new HashSet&lt;>();
		for (int index=0; index&lt;PRIME; index++)
			result.addAll(rows.get(index).entrySet());
		return result;
	}

}
</programlisting>
        <programlisting>package sajatHasMap;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;

public class LinkidMap&lt;K, V> implements Map&lt;K,V> {

	private Node&lt;K, V> root;
	
	public LinkidMap() {
		root = null;
	}
	
	private static class Node&lt;K,V> implements Map.Entry&lt;K, V>{
		
		private K key;
		private V value;
		private Node&lt;K, V> next;
		
		public Node(K key, V value, Node&lt;K, V> next) {
			super();
			this.key = key;
			this.value = value;
			this.next = next;
		} 
		
		 @Override
		public String toString() {
			// TODO Auto-generated method stub
			
			 String string ="Key: "+ getKey() +" "+ "Value: "+ getValue() ;
			 
			 return string; 
		}
		
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((key == null) ? 0 : key.hashCode());
			result = prime * result + ((value == null) ? 0 : value.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Node&lt;K,V> other = (Node&lt;K,V>) obj;
			if (key == null) {
				if (other.key != null)
					return false;
			} else if (!key.equals(other.key))
				return false;
			if (value == null) {
				if (other.value != null)
					return false;
			} else if (!value.equals(other.value))
				return false;
			return true;
		}
	
		public K getKey() {
			return key;
		}

		public void setKey(K key) {
			this.key = key;
		}

		public V getValue() {
			return value;
		}

		public V setValue(V value) {
			this.value = value;
			return  value;
		}

		public Node&lt;K, V> getNext() {
			return next;
		}

		public void setNext(Node&lt;K, V> next) {
			this.next = next;
		}
			
	}
	
	@Override
	public String toString() {
		Node&lt;K,V> currentNode = root;
		String string="LinkidMap [root]" ;
		while (currentNode != null) {
			string= string +" "+ currentNode.toString();
			currentNode=currentNode.getNext();
		}
		return string;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		Node&lt;K,V> current=root;
		while(current != null) {
			result = result +current.hashCode();
			current=current.next;
		}
		result = prime * result;
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		LinkidMap&lt;K,V> other = (LinkidMap) obj;
		if (root == null) {
			if (other.root != null)
				return false;
		} else {
			if (other.root == root)
				return true;//Ezz nincs tesztelve elméletileg nem is lehetne ilyen eset maximum a node setNext()-jével Null nál true-t add vissza
			if (this.root.key.getClass() != other.root.key.getClass())
				return false;
			if (this.root.value.getClass() != other.root.value.getClass())
				return false;
			Node&lt;K, V> current =root ;
			Node&lt;K, V> otherCurrent =other.root;
			boolean isItEquals = true; 
			while ((current.next != null)&amp;&amp;(otherCurrent.next != null) &amp;&amp; isItEquals) {
				isItEquals = current.equals(otherCurrent);
				current = current.next;
				otherCurrent =otherCurrent.next;
			}
			if ((current.next == null) &amp;&amp; (otherCurrent.next != null) || ((current.next != null) &amp;&amp; (otherCurrent.next == null) ) )
				return false;
			if (!isItEquals)
				return false;
		}
			
		return true;
	}

	@Override
	public int size() {
		int size = 0;	
		Node&lt;K,V> node =root;
		while (node != null) {
			
			node=node.getNext();
			size++;
			
		}
		return size;
	}

	@Override
	public boolean isEmpty() {
		
		if (root == null)
			return true;
		
		return false;
	}

	@Override
	public boolean containsKey(Object key) {
		// TODO Auto-generated method stub
		Node&lt;K,V> node =root;
		while (node != null) {
			if (node.getKey() == key) {
				return true;
			}else {
				node=node.getNext();
			}
		}
		
		return false;
	}

	@Override
	public boolean containsValue(Object value) {
		// TODO Auto-generated method stub
		
		Node&lt;K,V> node =root;
		while (node != null) {
			if (node.getValue() == value) {
				return true;
			}else {
				node=node.getNext();
			}
		}
		
		return false;
	}

	@Override
	public V get(Object key) {
		// TODO
		
		Node&lt;K,V> node =root;
		while (node != null) {
			if (node.getKey() == key) {
				return node.getValue();
			}else {
				node=node.getNext();
			}	
		}
		
		return null;
	}

	@Override
	public V put(K key, V value) {
		// TODO Auto-generated method stub
		if (!containsKey(key)) {
		Node&lt;K, V> node =new Node&lt;>(key,value,root);
		root = node;
		return value;
		}else {
			return null;
		}
	}

	@Override
	public V remove(Object key) {
		// TODO Auto-generated method stub első elem???
		Node&lt;K,V> befor =root;
		Node&lt;K,V> current=root;
		
		while (current != null) {
			if (current.getKey() == key) {
				befor.setNext(current.getNext());
				return current.getValue();
			} else {
				befor=current;
				current=current.getNext();
			}
			
		}
		
		return null;
	}

	@Override
	public void putAll(Map&lt;? extends K, ? extends V> m) {
		// TODO Auto-generated method stub
		//Sorendet nem tartja
		
		Set&lt;? extends K> keys = m.keySet();	
		for ( K key:keys) {
			this.put(key, m.get(key));			
		}
				
	}

	@Override
	public void clear() {
		// TODO Auto-generated method stub
		root=null;
	}

	@Override
	public Set&lt;K> keySet() {
		// TODO Auto-generated method stub
		Set&lt;K> keys =  new HashSet&lt;K>();
		Node&lt;K,V> currentNode =root;
		
		while (currentNode != null) {
			keys.add(currentNode.getKey());
			currentNode = currentNode.getNext();
		}
		
		return keys;
	}

	@Override
	public Collection&lt;V> values() {
		// TODO Auto-generated method stub
		
		Node&lt;K,V> currentNode =root;
		Collection&lt;V> collection =new ArrayList&lt;>();
		while (currentNode != null) {
			collection.add(currentNode.getValue());
			currentNode=currentNode.getNext();
		}
		return collection;
	}

	@Override
	public Set&lt;Entry&lt;K, V>> entrySet() {
		// TODO Auto-generated method stub
		Set&lt;Entry&lt;K, V>> result = new HashSet&lt;>();
		Node&lt;K,V> currentNode =root;
		while (currentNode != null) {
			result.add(currentNode);
			currentNode=currentNode.getNext();
		}
		
        return result;
	}
}</programlisting>
    </section>
	<section>
		<title>5. hét</title>
		<para>EPAM: It's gone. Or is it?</para>
		<para>
			<programlisting>public class BugousStuffProducer {
	private final Writer writer;

	public BugousStuffProducer(String outputFileName) throws IOException {
		writer = new FileWriter(outputFileName);
	}

	public void writeStuff() throws IOException {
		writer.write("Stuff");
	}

	@Override
	public void finalize() throws IOException {
		writer.close();
	}
}
</programlisting>
		</para>
		<para>Ha csak a writeStuff() eljárást hívjuk meg és a finalize()-t nem hívódik meg a program
			vége előtt akkor nem fog ki íródni a file-ba a bele írt szöveg.  A lapból a garbage
			collector hívja a finalize()-t de amíg ez nem történik meg nem záródik le a file egyes
			esetekben még a program le futása végén se hívódik meg.</para>
		<para>EPAM: Kind of equal</para>
		<programlisting>// Given
	String first = "...";
	String second = "...";
	String third = new String("...");
	// When
	boolean firstMatchesSecondWithEquals = first.equals(second);
	boolean firstMatchesSecondWithEqualToOperator = first == second;
	boolean firstMatchesThirdWithEquals = first.equals(third);
	boolean firstMatchesThirdWithEqualToOperator = first == third;
</programlisting>
		<para>A JVM optimalizációs célból fent tart egy string pool-t. Ha literálként hozzuk létre a
			string-et akkor először végig nézi a pool-ban hogy már létezik e az adott string ha igen
			akkor csak az adott string referenciájával tér vissza ha nem létezik létre hozza és bele
			rakja a pool-ba.</para>
		<para>Ezzel szembe ha a new operátorral végezzük ell a string létrehozását akkor mindig egy
			új objektum jön létre.</para>
		<para>Ebből következik az is hogy a first==second az true-val tér vissza mert ténylegesen
			ugyan azt az objektumot kapták meg a JVM-től, míg a Third.-nél új objektum jött létre
			ugyan azzal a tartalommal</para>
		<para>EPAM: Java GC</para>
		<para>Serial Garbage Collector</para>
		<para>Ez a GC legegyszerűbb megvalósítása. Alapvetően egyszálas környezetre tervezték. Ez a
			GC megvalósítás fagyasztja az összes alkalmazásszálat, amikor fut. Egyetlen szálat
			használ a garbage collection-höz. Ezért nem jó ötlet több szálon futó alkalmazásokban
			használni, például szerver környezetben.</para>
		<para>Parallel Garbage Collector</para>
		<para>Ez a GC a z előzővel ellentétben több szálon fut de ugyan úgy meg állítja az
			alkalmazást mint az előző. Be alíthatjuk a szálak számát, az rendelkezésére álló időt,
			maximum throughput-ot és a maximum heap footprintet.</para>
		<para>CMS Garbage Collector</para>
		<para>Az előzőhöz hasonlóan több szálat használ. Megkeresi é meg jelöli a heap memory-ban a
			törlendő objektumokat majd ki törli őket. olyan alkalmazásoknál célszerű használni
			melyek több kisebb meg állást preferálnak egy hosszabb helyet és képesek CPU időt
			biztositani a GC-nek.</para>
		<para>G1 Garbage Collector</para>
		<para>Arra tervezték hogy több CPU-s környezetbn nagy memória terület mellet dolgozzon jól.
			Felosztja egyenlő részekre a memóriát és párhuzamosan gyűjt belőlük. Kettő fázisa van
			Marking és Sweeping. Mindig annál a memória résznél kezdi a gyűjtést ami a leginkább
			üres </para>
		<para>Epsilon Garbage Collector</para>
		<para>Lefoglalja a memóriát a programnak de nem gyűjt szemetet ha tesztelni akarjuk a
			programot hogy menyi memóriát használ egy jóeszköz vagy ha ki akarjuk sajtolni a legjobb
			teljesítményt az adott programból. </para>
		<para>Z garbage collector</para>
		<para>A ZGC minden költséges munkát egyidejűleg végez, anélkül, hogy 10 ms-nál hosszabb
			időre leállítaná az alkalmazásszálak végrehajtását, ami alkalmassá teszi alacsony
			késleltetést igénylő alkalmazásokhoz és / vagy nagyon nagy heap memorit használó
			alkalmazásokhoz. Az Oracle dokumentációja szerint több terabájtos memóriát képes
			kezelni. A Z szemétgyűjtő a szálaiban végzi ciklusait. Átlagosan 1 ms-ig szünetelteti az
			alkalmazást. A G1 és a Parallel kollektorok átlagosan nagyjából 200 ms-ot tesznek
			ki.</para>
		<para>Shenandoah Garbage Collector</para>
		<para>Shenandoah memóriaterületeket használ annak kezelésére, hogy mely objektumok már
			nincsenek használatban, melyek élnek és készek a tömörítésre. Shenandoah emellett
			továbbít mutatót minden kupac objektumhoz, és az objektumhoz való hozzáférés
			ellenőrzésére használja. Shenandoah tervezése párhuzamos CPU-ciklusokat és helyet
			biztosít a szünetidő javítására. A továbbító mutató megkönnyíti az objektumok
			mozgatását, de az agresszív mozgások azt jelentik, hogy Shenandoah több memóriát
			használ, és több párhuzamos munkát igényel, mint más GC-k. De a rendkívüli munkát a
			világ rövid megállásaival végzi.</para>
		<para>out of memory</para>
		<para>Lehetséges ha elkapjuk az errot valahol és tudunk felszabadítani memóriát de nem
			lehetünk benne biztosak hogy a JVM milyen álapotban van éppen és menyire tudjuk vissza
			álitani. Jobb eljárás lenne inkább csak meg próbálni lezárni az erőforrásokat esetleg ki
			loggolni a hibát kiváltó tényzőket</para>
	</section>    
  
  <section>
        <title>Java osztályok a Pi-ben</title>
        <para>
            Az előző feladat kódját fejleszd tovább: vizsgáld, hogy Vannak-e Java osztályok a Pi hexadecimális kifejtésében!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>     
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
