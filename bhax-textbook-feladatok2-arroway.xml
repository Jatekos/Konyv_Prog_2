<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>0.hét</title>
      
        <para>
          Python: Forstner Bertalan, Ekler Péter, Kelényi Imre: Bevezetés a mobilprogramozásba.
      Gyors prototípus-fejlesztés Python és Java nyelven (35-51 oldal)
        </para>
        <para>
           Általános információk: A Python egy általános célú programozási nyelv. Guido van Rossum 1990-ben
      alkotta meg ezt a fejlesztők számára rengeteg pozitív tulajdonsággal rendelkező nyelvet, amely magas
      szintű, dinamikus, objektumorientált és platform- független. A fejlesztés megkönnyítéséhez magas szintű
      típusokat is támogat, mint például különféle listák és szótárak.
      Előnyei miatt az interpreter elkészítették a Symbian mobil operációs rendszer S60 platformja alá is, hogy
      megkönnyítsék az egyszerűbb szoftver és prototípusfejlesztést mobil készülékekre. A Python S60 implementáció
      nagy- részt lefedi az alap Pythont, azonban egy-két modult kihagytak belőle, amely nem kapcsolódik
      szorosan a mobileszközökhöz.
      A Python nyelv jellemzői Amikor alkalmazásokat fejlesztünk, sok esetben szükség van olyan részek megírására
      is, amelyek az adott probléma szempontjából nem relevánsak, el- készítésük mégis sok időt vesz
      igénybe. Ilyenek például a különféle fájlkezelő metódusok, hálózatkezelés, GUI kialakítása stb. A szokásos
      programírás/fordítás/tesztelés/újra fordítás ciklust egy professzionális C, C++ vagy Java-fejlesztő is
      lassúnak találja egy idő után, márpedig erre minden módosítás esetében szükség van. A Python ebben is
      segít, esetében ugyanis nincs szükség a fordítás fázisára, az értelmezőnek elegendő a Python- forr
      A Python nyelv legfőbb jellemzője, hogy behúzásalapú a szintaxisa. A prog- ramban szerepl˝o állításokat
      az azonos szint˝u behúzásokkal tudjuk csoportok- ba szervezni, nincs szükség kapcsos zárójelre vagy explicit
      kulcsszavakra (pl. begin, end). Egy adott blokk végét egy kisebb behúzású sor jelzi, tehát például
      üres sor lehet a blokkon belül. A szkript els˝o utasítása nem lehet behúzott. Fontos, hogy a behúzásokat
      egységesen kezeljük, tehát vagy mindenhol tabot, vagy egységesen szóközt használjuk. Bizonyos szövegszerkeszt
      ˝okben akár azt is beállíthatjuk, hogy a tab billenty˝u lenyomása 4 szóközt jelentsen. A nyelv
      további sajátossága, hogy a sor végéig tart egy utášítás, nincs szükség a megszokott ;’ használatára.
      Pythonban minden adatot objektumok reprezentálnak. Az adatokon végezhe- t˝o m˝uveleteket az objektum
      típusa határozza meg. Pythonban nincs szükség a változók típusainak explicit megadására, a rendszer 
      futási id˝oben, automa- tikusan „kitalálja" a változók típusát a hozzárendelt érték alapján. Az adattípusok a
      következ˝ok lehetnek: számok, sztringek, ennesek (tuples, n-es), listák, szótárak (dictionaries).
      Változók és alkalmazásuk Pythonban a változók alatt az egyes objektumokra mutató referenciákat ér- tünk.
      Maguknak a változóknak nincsenek típusai, így egy szkript futása so- rán bármely, akár különböz˝o típusú
      objektumra is hivatkozhatnak. Ameny- nyiben egy objektumra az utolsó hivatkozást is töröljük (pl. a változói
      már más objektumokra mutatnak), az automatikus garbage collector szabadítja fel a memóriaterületet.
      A nem létez˝o változókra való hivatkozás futás közbeni kivételt okoz.
      Pythonban függvényeket a def kulcsszóval definiálhatunk. A függvényekre mint értékekre is tekinthetünk,
      hiszen azok továbbadhatók más függvények- nek, illetve objektumkonstruktoroknak is. A függvények
      rendelkeznek para- méterekkel, amelyeknek, a szokásos megkötésekkel és szintaxissal, alapér- telmezett
      értéket is adhatunk. A paraméterek érték szerint adódnak át, kivé- ve az úgynevezett mutable típusok (pl.
      listák, szótárak), amelyek függvénybe- li megváltoztatása hatással van a hívókódrészletben lév˝o objektumra
      is. Az egyes paramétereknek a szokásos szintaxissal (paraméter értelmezett értéket is adhatunk.
      A Python nyelv támogatja a klasszikus, objektumorientált fejlesztési eljárá- sokat, amelyeket ebben az
      alfejezetben röviden átnézünk. Definiálhatunk osztályokat, amelyek példányai az objektumok. Az osztályoknak
      lehetnek att- ribútumaik: objektumok, illetve függvények. Ez utóbbiakat metódusoknak vagy
      tagfüggvénynek is hívjuk. Ezenkívül az osztályok örökölhetnek más osz- tályokból is.
        </para>

      <para>
        Összehasonlítás c++ java:
      </para>
      
      <para>
        kifejezés fogalom ua.:Kifejezések olyan kód részletek amelyek valami műveletet végeznek és a művelet eredményét adják vissza, vagy pedig valami értéket reprezentálnak.
        ,
        stb:Java esetén egy osztály definíciója és deklarációja,azaz az eljárások feje és megvalósítása nem szétválasztható, mint például C++-ban.
        Ahogy C++-ban, úgy a Javában is felsorolhatunk változókat,de a Java megengedi, hogy inicializáljuk is azokat,konstruktoron kívül
        konstruktor: Ennek neve – ahogy C++-ban is – megegyezik az osztály nevével, nincs visszatérési értéke.
        final: Végleges, azaz konstans érték (nem ugyanaz mint a C++ const! Hiszen itt a referencia az az érték, ami nem változtatható, de ettől még a hivatkozott objektum állapota változtatható)
        Javában minden metódus olyan, mint C++-ban a virtual kulcsszóval ellátottak.Itt a dinamikus kötés automatikusan létrejön! Ha a metódus az osztályban nem static jelzővel illetett, akkor nincs olyan momentum, amely egyértelműen az alaposztályához kötné (azaz példánymetódus). A kötés ekkor csakis dinamikus lehet, ami azért érdekes helyzet, mert előre senki sem tudhatja (legfőképpen a JVM nem), hogy éppen melyik példánymetódus fut, azaz a kötés csakis a futási idő alatt jöhet létre. Ezért illetik egyúttal a dinamikus kötést a következő jelzőkkel:futás alatti kötés:runtime binding,
        ,késői kötés - late binding, illetve dinamikus kötés alatti példánymetódus-keresés folyamatát dinamikus metóduskeresésnek (dynamic method lookup). A keresés végeredménye ebben az esetben csakis az lehet, hogy az éppen aktuálisan futó objektum kerül végrehajtásra. c++ ehhez a virtual jelzőt kell használni
        Javában minden objektum:referencia:
        klónozás
        A java a c++-al ellentétben platform független mivel egy virtuális gépen fut ez a JVM és JRE ezen felül van a JDK ami már a java programok fejélesztéséhez szükséges. Ebből következik, hogy a java programoknak rosszabb az optimalizáltságga  a c+++ hoz képes amit a fordító programok gépi nyelvre fordítanak de szintén ebből következik hogy könnyebben hordozhatók és biztonságosabbak a java programok.

        C++ elsősorban rendszerprogramozásra használják míg A javat alkalmazások fejlesztésére. Széleskörben használják webes, mobilos alkalmazások fejlesztésére. Ennek fő okai a könnyű egységekre bontás és tagolása a programoknak.

        Goto utasítás a c6+ támogatja de a java nem . (de alapvetően egy jól struktúrát programban nincs is szükség a goto utasítás használatára)

        A c++ támogatja a többszörös öröklődést míg a java nem támogatja a többszörös öröklődést osztályok között.DE az interfacek használatával a jávában is át hidalható ez a probléma

        Az operátor túlterhelést nem támogatja a java a c++-al szemben ahol ez egy bevet metódus a javaban külön függvények segítségével oldható fel ez a probléma.,

        Míg c++ teljesen támogatja a pointerek felhasználását a programokban addig a java csak belsőleg támogatja őket nem írható mutatókat explicite használó program.
        Ez azt jelenti, hogy a java korlátozta a mutató támogatását

        C++ ban mind érték mind referencia alapján lehet hívni addig java nem támogatja a referencia alapú hívást csak érték alapú hívások vannak a jávában.

        A java mindig egy öröklődési fát tartalmaz mert minden osztály az Object class gyermeke. A jávában mindig az Object Class a gyökere az öröklődési fának. Ezzel szemben a c++ mindig új öröklődési fát készít.
        A jdk JRE JVM felépitéséből adódóan a Java nem lép kapcsolatba közvetlenül a hardwarerel míg a c++ fordítási metódusából adódóan az abban írt programok igen.

      </para>
      
       
    </section>        

    <section>
        <title>1.hét</title>
        <para>
            Eljárás orientál vs Objektumorientált
        </para>
        <para>
          
Elsőként tisztázzuk a két fogalmat. Az eljárás orientált nyelvek alatt azokat értjük melyek struktúrát programozási elvek alapján működnek, mely eljárás híváson alapszik. Ezek az eljárások a program során bármikor meg hívhatóak, akár saját magukat is hívhatják. A feladatokat lépésről lépésre bontja le az eljárás orientált program változókra és eljárásokra melyek szekvenciális utasításokat tartalmaznak. Ezzel szemben az Objektumorientált nyelvek az objektumokon alapszanak melyeknek vannak tulajdonságuk és viselkedésük melyekkel képesek megváltoztatni a saját és más objektumok tulajdonságait.
Az elmondható mind két paradigmáról, hogy kisebrészekre bontják fel a problémát ezen keresztül pedig a kódot is. A nagy különbség a kettő féle felbontásban az hogy az objektumorientáltnál sokall könnyebb utólagosan változtatni a programon egy jól meg tervezet programnál csak az adott objektumon kel választani. Míg az eljárás orientáltnál mivel az egész egy programként kezelődik így az egész program változik. Ebből következik az is, hogy az objektumorientált programok sokkal modulárisabbak egyes modulokat akár több programnál is fel lehet használni ezáltal és az által, hogy jobban tagolható az írása rövidül a fejlesztési idő is.
Objektumorientált nyelvekben lehet szabályozni a láthatóságot (public, private, protected) mely segítségével elrejthetők az adatok ezáltal biztonságosabb mint az eljárásorientált nyelvek ahol erre nincs lehetőség.
Az objektum orientált nyelveknél könnyebb bővítés az öröklődésnek köszönhetően. Erre az eljárás orientált nyelveknél nincs lehetőség.
        </para>
        <para>
           Java Object metódusok :              
        </para>
        <para> protected Object clone(): Vissza tér egy másolatával az adott objektumnak. x.clone()
			!= x igazat fog adni, x.clone().equals(x) igazat fog adni de ez nem elvárás. A
			használathoz felül kel definiálni, a protected miatt nem látszik. Ha az adot osztály nem
			implementálja a cloneable interface-t akkor metódus hívása CloneNotSupportedException
			fog okozni. Maga az interface nem tartalmazza a clone metódus törzsét ,így csak az
			implementálása nem elegendő a metódus használatához. </para>
    <para>
            Boolean equals​(Object obj) : megalapítja hogy egy objectum egyenlő-e azzal amelyből hívjuk. Abban az esetben kell felüldefiniálni ezt a  metódust ha az adott objektum más objektumot is tartalmaz mer ebben az esetben az objektum == operátorral hasonlítja össze és így csak akkor ad igazat ha ugyan arra a helyre mutatnak. Abban az esetben ha felül definiáljuk a  equals() metódust a hasCode() metódust is illik felüldefiniálni mivel az egyenlő objectumoknak ugyan annak kell lenije a has kódjának.
        </para>
          <para>
            Class  getClass() Visszatér az osztállyal futás időben mellyel különböző információkat nyerhetünk ki az osztályról.
        </para>
        <para>
            Int hashCode() Vissza tér egy has értékel az objektumra.
Egy futtatás alatt egy adott objektumnak nem szabad változnia a has kódjának de futások között már változhat
ha két objectom egyenlő az  equals(Object) metódus alapján akkor ugyan azt a has értéket kell hogy kapják
az nem elvárás ha két objektum különbözik akkor külön hash kódot kapjanak
        </para>
        <para>
            Void notify() Egyetlen szálat ébreszt fel, amely az objektum monitorára vár. Az felébresztett szál addig nem folytatódik, amíg az aktuális szál nem oldja fel az objektum zárolását csak az objektum „gazdája” adhatja ki ezt az utasítást. A fel ébresztett szál nem élvez semmilyen előjogot az objektumra
        </para>
        <para>
            Void notifyAll() Minden szálat  fel ébreszt , amely az objektum monitorára vár. A fel ébresztett szálak nem élveznek semmilyen előjogot az objektumra
        </para>
        <para>
            String toString()	 Egy stringgle tér vissza ami meg adja az objektumot érdemes felül definiálni alapértelmezetten ezt a kifejezést adja vissza: getClass().getName() + '@' + Integer.toHexString(hashCode())
        </para>
  <para>
            Void wait() A aktuális szál várását eredményezi míg fel nem ébresztik,vagy meg nem szakítják.
        </para>
     <para>
            Void wait​(long timeout, int nanos)  aktuális szál várását eredményezi míg fel nem ébresztik,vagy meg nem szakítják vagy el nem telik a meg adott idő
        </para>
      
    <para>
      Singleton Design Pattern:
      </para>
      <para>
Biztosítani kel, hogy csak egy objektum jöhessen létre az adott osztályból, ezt az objektumot mindenkinek el kel érnie. Ez azzal jár, hogy a lazán kell iniciálni az adott objektumot. 
Előállítása: összes konstruktort felül kell definiálni egy protecteddel vagy private függvénnyel és kel egy statikus függvény ami hívja a konstruktort ha még nem létezik az adott objektum
Akkor érdemes használni ha egy objektumból pontosan egy darab kell pl.:facade objestc,State object.
</para><para>
Abstract Factory Design Pattern
</para><para>
A lényege a Abstract Factory-nek hogy interfacet adjon ahhoz hogy családokat hozzunk létre összetartozó objektumokból. A japán autó gyártásban használt modellt modellezi ahol egy prés
kis változásokkal képes több típus adott elemét elő állítani. A programozásban a hordozhatóságra ad egy megoldást ahol az adott rendszerhez kell alkalmazkodni de ez sok #ifdef részel járhat a programban.(sokszor használ singletont az egyes objektumok hoz)
</para><para>
Builder Design Pattern
</para><para>
El választja az elkészítését egy összetett objektumnak a reprezentációjától és ezzel eléri, hogy ez az eljárás képes legyen különböző  reprezentációkat el készíteni. 
</para><para>
Factory Method Design Pattern:
</para><para>
Meg ad egy felületet egy objektum létrehozásához, de hagyja, hogy az alosztályok döntsék el, melyik osztályt kell példányosítani.
A Factory Method lehetővé teszi, hogy az osztály megengedi az alosztályok példányosítását. Definiál egy virtuális konstruktort. A new operátor ártalmas lehet.
</para><para>
Object Pool Design Pattern
</para><para>
Az object pool jelentős teljesítménynövekedést kínálhat; leghatékonyabb azokban a helyzetekben, amikor az osztálypéldány inicializálásának költsége magas, az osztály példányosítási aránya magas, és az egyszerre használt példányszám alacsony.
Az Object Pool (más néven erőforráskészletek) az objektum-gyorsítótár kezelésére szolgálnak. Az Objektumkészlethez hozzáférő kliens elkerülheti az új Objektumok létrehozását, ha egyszerűen megkéri a készletet hogy adjon egy már példányosítottat. Általában a pool növekvő medence lesz, vagyis maga a pool új objektumokat hoz létre, ha a pool üres, vagy rendelkezhetünk pool-lal, ami korlátozza a létrehozott objektumok számát.
</para><para>
Prototype Design Pattern
</para><para>
létre hoz egy objektumot majd ezt az objektumot módosítja és clonozza ehez használnia kell a clone abel interfészt .  A new operátor káros. Egy objektum az őse minden objekumnak
    </para>

      <para>
        OO szemlélet
      </para>
      <para>
        C++ ban:
      </para>
      <programlisting language="c++">
        <![CDATA[
#include <iostream>
#include <cstdlib>
#include <cmath>
#include <ctime>

class ElsoOsztajom
{
private:
    bool letezikKovVeletlen;
    double kovVeletlen;
public:
    ElsoOsztajom();
    ~ElsoOsztajom();

    double veletlen();
};

ElsoOsztajom::ElsoOsztajom()
{
    letezikKovVeletlen=false;
}

ElsoOsztajom::~ElsoOsztajom()
{
}

double ElsoOsztajom::veletlen()
{
    if (letezikKovVeletlen)
    {
        letezikKovVeletlen =false;
        return kovVeletlen;
    }
    else
    {
        double u1, u2, v1, v2, w;
        do 
        {
            u1=std::rand()/(RAND_MAX+1.0);
            u2=std::rand()/(RAND_MAX+1.0);
            v1=2*u1-1;
            v2=2*u2-1;
            w=v1*v1+v2*v2;
        }
        while (w>1);
        double r =std::sqrt((-2*std::log(w))/w);
        
        kovVeletlen=r*v2;
        letezikKovVeletlen =true;
        
        return r*v1;
    }
    

}

int main(){
    double j=0;
    ElsoOsztajom r;
    for (int i=0; i<5; i++)
    {
        j=r.veletlen();
        std::cout<<j<<std::endl;
    }
   
}]]>
      </programlisting>


      <para>
        Javaban:
      </para>
      <programlisting language="c++">
        <![CDATA[
PolarGenerator:
        
package ooszemlelet;

import java.lang.Math;

public class PolarGenerator {
	
	private boolean isStored = false;
	private double stord;
	
	public double giveTheNext() {
		
		if (isStored) {
			
			isStored = false;
			return stord; 
			
			
		} else {
			
			double u1, u2, v1, v2 ,w;
			
			do {				
				u1 = Math.random();
				u2 = Math.random();
				v1 = 2 * u1 - 1;
				v2 = 2 * u2 - 1;
				w = v1 * v1 + v2 * v2;				
			}
			while (w>1);
			
			double r =Math.sqrt((-2 * Math.log(w)) / w);
			stord=r * v2;
			isStored = true;
			return r*v1;
						
		}
	}
	
	
	
}


Main:

package ooszemlelet;



public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		PolarGenerator g = new PolarGenerator();
		for (int i=0; i<10 ; i++) {
			System.out.println(g.giveTheNext());
		}

	}

}

]]>
      </programlisting>


    </section>
    <section>
        <title>2.hét</title>
        <para>EPAM:Interfész evolúció Java ban</para>
        <para>A java 8 élőt csak abstract metódust lehetet az interfészekben használni. Minden
			metódus public és abstract alapból. A java 8 tól kezdve lehet default és static
			metódusokat is használni. A default metódus lehetővé teszi a fejlesztőnek hogy anélkül
			adjn hozzá az iterface-hez egy metódust hogy azzal befolyásolná azokat az osztályokat
			amelyek használják az adott interfacet. Ezt a tulajdonságot nevezhetjük vissza felé
			kompatibilitásnak is mivel ezzel a képességet ki használva egy létező kódba tudunk új
			funkciót belerakni anélkül hogy tönkretennék a már létező kódot vagy teljesen újra
			kellene írnunk. A staticus metódusok hasonlóan viselkednek a default metódusokhoz azzal
			a különbséggel hogy ezeket a metódusokat nem lehet felülírni az osztályokban. Ez a két
			új funkció felveti a többszörös öröklődés kérdését is, ha van két interface amiben van
			egy egy ugyan olyan nevű metódus és egy osztály egyszere implementálja mind két
			interfacet nem lehet eldönteni hogy melyik metódus futsonle. Erre egy megoldás ha az
			ilyen metódusokat felül definiáljuk</para>
        <para>EPAM:Liskov féle helyettesíthetőség elve, öröklődés</para>
        <para>osztály definiciók:</para>
        <programlisting> public class Vehicle {

    public Vehicle() {
        System.out.println("Creating vehicle!");
    }

    void start() {
        System.out.println("Vehicle is starting!");
    }

}
 </programlisting>
        <programlisting>  public class Car extends Vehicle {
     
    public Car() {
        System.out.println("Creating car!");
    }

    @Override
    void start() {
        System.out.println("Car is starting!");
    }

}
</programlisting>
        <programlisting> package com.epam.training;

public class Supercar extends Car {

    public Supercar() {
        System.out.println("Creating supercar!");
    }

    @Override
    void start() {
        System.out.println("Supercar is starting!");
    }

}
 </programlisting>
        <para>tesztelése:</para>
        <programlisting>Vehicle firstVehicle = new Supercar();
firstVehicle.start();
System.out.println(firstVehicle instanceof Car);
</programlisting>
        <para>kimenet:</para>
        <programlisting>Creating vehicle!
Creating car!
Creating supercar!
Supercar is starting!
true</programlisting>
        <para>A firstVehicle létrehozásánál mivel Supercar-ból let létre hozva ezért lefut a Vehicle
			a Car és a Supercar konstruktora is de mivel a firstVehicle Vehicle típusú így ezen a
			változón nem érhetőek el sem a Car sem a Supercar azon metódusai amelyek nem egy Vehicle
			belli metódust írnak felül.</para>
        <programlisting>Car secondVehicle = (Car) firstVehicle;
secondVehicle.start();
System.out.println(secondVehicle instanceof Supercar);

System.out.println(firstVehicle.toString());
System.out.println(secondVehicle.toString());</programlisting>
        <para>kimenet:</para>
        <programlisting>Supercar is starting!
true
com.epam.training.Supercar@25618e91
com.epam.training.Supercar@25618e91</programlisting>
        <para>Az érték adásnál Car-t adunk át Car-nak de mivel az átadot Car egy Supercar volt így
			átadás után is az marad mert csak a címét adta át az objektumnak. </para>
        <programlisting>
Supercar thirdVehicle = new Vehicle();
thirdVehicle.start();</programlisting>
        <para>Itt mivel a Supercar bőveb mint a Vehicle nem tudja belőle létrehozni .</para>
        <para>EPAM: Interfész, Osztály, Absztrak Osztály</para>
        <para>Az interfacekkel teljes szintű absztrakció valósítható meg míg a abstract osztállyal
            csak részleges absztrakció valósítható meg. Az interface egy tervrajzhoz hasonlítható míg
            az abstract class csak azt engedi meg hogy az eredeti class egyes részeit mi mondhatjuk
            meg hogy definiáljuk</para>
        <programlisting>package abstractClassClass;

public abstract class IntegerStorage {
	
	int [] storage;
	int numberOfElement;
	final int MAX_NUMBER_OF_ELEMENT=10;
	
	public IntegerStorage() {
		super();
		this.storage =  new int [MAX_NUMBER_OF_ELEMENT];
		numberOfElement = -1;
	}
	
	abstract public void add(int value);
	abstract public int get();
	abstract public boolean contain(int value);


}
</programlisting>
        <programlisting>package abstractClassClass;

public class IntegerStorageFiFo extends IntegerStorage{

	@Override
	public void add(int value) {
		if (numberOfElement &lt;MAX_NUMBER_OF_ELEMENT) {
			numberOfElement++;
			storage[numberOfElement] = value;
		}
		
	}

	@Override
	public int get() {
		numberOfElement--;
		return storage[numberOfElement+1];
	}

	@Override
	public boolean contain(int value) {
		int i=0;
		while ((i&lt;=numberOfElement)&amp;&amp; (storage[i]!= value)) {
			i++;
		}
		
		if (i&lt;=numberOfElement) {
			return true;
		}else {
			return false;
		}
	}
	

}
</programlisting>
        <programlisting>package interfaceClass;

public interface IntegerStorage {

	public void add(int value);
	public int get();
	public boolean contain(int value);
	
}
</programlisting>
        <programlisting>package interfaceClass;

public class IntegerStorageFiFo implements IntegerStorage {

	int [] storage;
	int numberOfElement;
	final int MAX_NUMBER_OF_ELEMENT=10;
	
	public IntegerStorageFiFo() {
		super();
		this.storage =  new int [MAX_NUMBER_OF_ELEMENT];
		numberOfElement = -1;
	}

	public void add(int value) {
		
		if (numberOfElement &lt;MAX_NUMBER_OF_ELEMENT) {
			numberOfElement++;
			storage[numberOfElement] = value;
		}
		
	}

	public int get() {
		numberOfElement--;
		return storage[numberOfElement+1];
	}

	public boolean contain(int value) {
		int i=0;
		while ((i&lt;=numberOfElement)&amp;&amp; (storage[i]!= value)) {
			i++;
		}
		
		if (i&lt;=numberOfElement) {
			return true;
		}else {
			return false;
		}
	}
 
}
</programlisting>
        <para>A példában bemutat kódban az abstrac class nál meg adjuk hogy milyen adat szerkezetet
            használunk de azt nem hogy ezzel hogyan dolgozunk, míg az interface nél ezt se adtuk meg
            teljesen független tőle csak azt adtuk meg hogy milyen metódusokat használjon. Az
            abstrakció szintjétől/igényétől függ hogy melyiket érdemes használni. Ha pedig egyáltalán
            nics absztrakcióra szükség akkor érdemes Class-t használni. Az interfacek e mellet arra
            is jók hogy egy azt implikáló osztályt tudjunk használni annak a belső működése ismerete
            nélkül. Ez elő segíti program kód tagolását is.</para>
    </section>
    <section>
        <title>3.hét</title>
        <para>EPAM: Neptun tantárgyfelvétel modellezése UML ben</para>
        <para><inlinemediaobject>
                <imageobject>
                    <imagedata fileref="./Targyfelveteluml.png"/>
                </imageobject>
            </inlinemediaobject></para>
        <para>EPAM: Neptun tantárgyfelvétel UML diagram implementálása</para>
        <para>Abstract class NeptunEntity</para>
        <para>Azt az osztályt azért hoztam létre mert voltak azonos attribútumaik a Student-nek és a
            Lessen-nek</para>
        <programlisting>package targyfelvetel;

public abstract class NeptunEntity {
	protected String neptunCode;
	protected String name;
	
	
	
	
	public NeptunEntity(String neptunCode, String name) {
		super();
		this.neptunCode = neptunCode;
		this.name = name;
	}
	protected String getNeptunCode() {
		return neptunCode;
	}
	protected void setNeptunCode(String neptunCode) {
		this.neptunCode = neptunCode;
	}
	protected String getName() {
		return name;
	}
	protected void setName(String name) {
		this.name = name;
	}
	
	
}
</programlisting>
        <para>Lessen class felelős az órákért azoknak az adatainak a tárolásáért és
			beállításaiért</para>
        <programlisting>package targyfelvetel;

import java.util.Map;

public class Lessen extends NeptunEntity{
	
	boolean takeAble;
	int maxNumberStudent;
	int currentNumberOfStudent;
	//TODO linkidmap cserélni map re 
	
	private Lessen(String neptunCode, String name, int maxNumberStudent) {
		super(neptunCode, name);
		this.takeAble = true;
		this.maxNumberStudent = maxNumberStudent;
		this.currentNumberOfStudent = 0;
	}
	
	static public void getANewLessen(Map&lt;String, Lessen>lessens,String neptunCode, String name, int maxNumberStudent) {
		
		Lessen curentLessen=new Lessen(neptunCode, name, maxNumberStudent);
		lessens.put(neptunCode, curentLessen);
	}


	public boolean isTakeAble() {
		return takeAble;
	}


	public void setTakeAble(boolean takeAble) {
		this.takeAble = takeAble;
	}


	public int getMaxNumberStudent() {
		return maxNumberStudent;
	}


	public void setMaxNumberStudent(int maxNumberStudent) {
		this.maxNumberStudent = maxNumberStudent;
	}


	public int getCurrentNumberOfStudent() {
		return currentNumberOfStudent;
	}
	
	public boolean chekTakeAble() {
		if (currentNumberOfStudent&lt;maxNumberStudent) {
			setTakeAble(true);
			return true;
		}else {
			setTakeAble(false);
			return(false);
		}
	}
	
	public void incrementCurrentNumberOfStudent() {
		this.currentNumberOfStudent++;
	}


	public void setCurrentNumberOfStudent(int currentNumberOfStudent) {
		this.currentNumberOfStudent = currentNumberOfStudent;
	}
	
	
	
}
</programlisting>
        <para>Student class képes tárgyat felvenni (ezáltal változást is tud okozni a Lessen-ben ez
            felvethet némi problémát)</para>
        <programlisting>package targyfelvetel;

import java.util.Map;

public class Student extends NeptunEntity {

	LinkidMap&lt;Integer, String> takenLessen;
	int numberOfTakenLessen;

	private Student(String neptunCode, String name) {
		super(neptunCode, name);
		this.takenLessen = new LinkidMap&lt;>();
		numberOfTakenLessen = 0;
	}

	public static Student getANewStudent(String neptunCode, String name) {
		Student currentStudent = new Student(neptunCode, name);
		return currentStudent;
	}

	public void takeLesson(Map&lt;String, Lessen> lessens, String lessenCode) throws Exception {

		if (lessens.containsKey(lessenCode)) {
			Lessen currentLessen;
			currentLessen = lessens.get(lessenCode);
			if (currentLessen.chekTakeAble()) {
				setNumberOfTakenLessen(getNumberOfTakenLessen() + 1);
				currentLessen.incrementCurrentNumberOfStudent();
				takenLessen.put(this.numberOfTakenLessen, lessenCode);
				
			}else {
				throw new Exception("Lessen is not take able "+ lessenCode);
				}
			
		} else {
			throw new Exception("Lessen dosen' t exists "+ lessenCode);
		}

		
	}

	public LinkidMap&lt;Integer, String> getTakenLessen() {
		return takenLessen;
	}

	public void setTakenLessen(LinkidMap&lt;Integer, String> takenLessen) {
		this.takenLessen = takenLessen;
	}

	public int getNumberOfTakenLessen() {
		return numberOfTakenLessen;
	}

	public void setNumberOfTakenLessen(int numberOfTakenLessen) {
		this.numberOfTakenLessen = numberOfTakenLessen;
	}

}</programlisting>
        <para>A neptun class ban vannak tárolva az órák és a hallgatók és itt tudjuk őket létre
            hozzni</para>
        <programlisting>package targyfelvetel;

public class Neptun {

		LinkidMap&lt;String, Lessen> lessens = new LinkidMap&lt;>();
		LinkidMap&lt;String, Student> students = new LinkidMap&lt;String, Student>();
		
		public Neptun() {
			
			
		}
		
		public void AddAStudent(String neptunCode,String name) {
			students.put(neptunCode,Student.getANewStudent( neptunCode, name));
		}
		
		public void AddALessen(String neptunCode,String name, int maxNumberStudent) {
			Lessen.getANewLessen(lessens, neptunCode, name, maxNumberStudent);
		}
		
}
</programlisting>
        <para>EPAM:OO modellezés</para>
        <para>SOLID</para>
        <itemizedlist>
            <listitem>
                <para>Single-responsibility principle</para>
                <para>Egy osztálynak csak egyetlen felelőssége kell, hogy legyen, vagyis a szoftver
                    specifikációjának csak egy részén végzett változtatások befolyásolhatják az
                    osztály specifikációját. </para>
            </listitem>
            <listitem>
                <para>Open–closed principle</para>
                <para>A szoftvereknek nyitva kell lenniük a kiterjesztésre, de módosításra
                    bezárva.</para>
            </listitem>
            <listitem>
                <para>Liskov substitution principle</para>
                <para>Egy objektumot bármikor helyettesíthet egy all osztálya az adott
                    objektumnak</para>
            </listitem>
            <listitem>
                <para>Interface segregation principle</para>
                <para>Jobb mindenre külön külön interface csinálni ,mint egy univerzálisat
                    használni</para>
            </listitem>
            <listitem>
                <para>Dependency inversion principle</para>
                <para>Az absztrakciónak kell az alapját szolgálnia a programoknak nem konkréttan
                    megírt kódok</para>
            </listitem>
        </itemizedlist>
        <para>KISS</para>
        <para>A KISS (keep it stupid simple/keep it simple, soldier) elv szerint a legtöbb rendszer
            akkor működik a legjobban, ha egyszerűbbé teszik, nem pedig bonyolulttá teszik őket;
            ezért a tervezésnél az egyszerűségnek kell kulcsfontosságúnak lennie, és kerülni kell a
            felesleges bonyolítást.</para>
        <para>DRY</para>
        <para>Don't repeat yourself</para>
        <para>Minden információnak egy elfordulásának kell hogy legyen a rendszerben (kétszer ugyan
            azt a a kódot felesleges megírni csak hibaforrás lesz)</para>
        <para>YAGIN</para>
        <para>You ain't gonna need it</para>
        <para> Addig nem kell létre hozni egy függvény míg nincs rá szükséged még akkor se ha azt
            sejted hogy szükséged lesz rá</para>
    </section>
    <section>
        <title>4.hét</title>
        <para>EPAM: Order of everything</para>
		<programlisting>package com.epam.training;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

/**
 * # Order of everything
 *
 * Collection-ok rendezĂ©se esetĂ©n jellemzĹ‘en futĂˇsi idĹ‘ben derĂĽl ki,
 * ha olyan tĂ­pusĂş objektumokat prĂłbĂˇlunk rendezni, amelyeken az Ă¶sszehasonlĂ­tĂˇs
 * nem Ă©rtelmezett (azaz `T` tĂ­pus esetĂ©n nem implementĂˇljĂˇk a `Comparable&lt;T>` interface-t).
 * Pl. ClassCastException a [Collections.sort()](https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#sort(java.util.List)) esetĂ©ben,
 * vagy ClassCastException a [Stream.sorted()](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#sorted--) esetĂ©ben.
 *
 * ĂŤrj olyan metĂłdust, amely tetszĹ‘leges Collection esetĂ©n vissza adja az elemeket
 * egy List-ben nĂ¶vekvĹ‘en rendezve, amennyiben az elemek Ă¶sszehasonlĂ­thatĂłak velĂĽk azonos tĂ­pusĂş objektumokkal.
 * Ha ez a feltĂ©tel nem teljesĂĽl, az eredmĂ©nyezzen syntax error-t.
 *
 * PĂ©ldĂˇul:
 * ```
 *     List&lt;Integer> actualOutput = createOrderedList(input);
 * ```
 * Ahol az `input` `Collection&lt;Integer>` tĂ­pusĂş. TermĂ©szetesen mĂˇs tĂ­pusokkal is mĹ±kĂ¶dnie kell,
 * feltĂ©ve, hogy implementĂˇljĂˇk a Comparable interface-t.
 */
public class OrderOfEverythingTest {

    @Test(dataProvider = "collectionsToSortDataProvider")
    public void testOrderShouldReturnExpectedListWhenCollectionIsPassed(Collection&lt;Integer> input, List&lt;Integer> expectedOutput) {
        // Given as parameters

        // When
        // createOrderedList(List.of(new OrderOfEverythingTest()));
        // ^ ez piros, az OrderOfEverythingTest nem implementĂˇlja a Comparable&lt;OrderOfEverythingTest> -et
        List&lt;Integer> actualOutput = createOrderedList(input);

        // Then
        assertThat(actualOutput, equalTo(expectedOutput));
    }

    @DataProvider
    private Object[][] collectionsToSortDataProvider() {
        return new Object[][] {
            {Collections.emptySet(), Collections.emptyList()},
            {Set.of(1), List.of(1)},
            {Set.of(2,1), List.of(1,2)}
        };
    }

    private &lt;T extends Comparable&lt;T>> List&lt;T> createOrderedList(Collection&lt;T> input) {
        return input.stream()
            .sorted()
            .collect(Collectors.toList());
    }
}
</programlisting>
        <para>EPAM: Bináris keresés és Buborék rendezés
			implementálása<programlisting>package IntegerStorage;

import java.util.Arrays;

public class IntegerStorage {
	private int[] storage;
	private int index = 0;

	public IntegerStorage(int size) {
		super();
		this.storage = new int[size];
	}

	public IntegerStorage(int[] storage) {
		super();
		this.storage = storage;
		this.index = storage.length;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.hashCode(storage);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		IntegerStorage other = (IntegerStorage) obj;
		if (!Arrays.equals(storage, other.storage))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return "IntegerStorage [storage=" + Arrays.toString(storage) + "]";
	}

	public void add(Integer value) {
		storage[index++] = value;
	}

	public boolean contains(Integer value) {
		int u = 0;
		int v = index-1;
		boolean l = false;

		sort();

		while ((l == false) &amp;&amp; (u &lt;= v)) {
			int i=(u+v)/2;
			            
			if (storage[i]==value)
				l =true;
			
			if(storage[i]&lt;value)   
				u=i+1;
			
			if(storage[i]>value)
				v=i-1;
			
		}  

		return l;

	}

	public int[] sort() {

		for (int i = index - 1; i >= 0; i--) {
			for (int j = 0; j &lt; i; j++) {
				if (storage[j] > storage[i]) {
					int s;
					s = storage[j];
					storage[j] = storage[i];
					storage[i] = s;
				}
			}

		}

		return storage;
	}

}</programlisting></para>
        <para>EPAM: Saját HashMap implementáció</para>
        <para>Egy Hash map kialakításához egty ArrayList-et használtam melybe Map-eket hoztam létre
            (ez a saját magam által meg írt linkedmap volt)ez álltan láncolt listával oldom meg az
            ugyan olyan hash kódú elemek tárolását de igazából a HashMap szempontjából/működéséből
            következően annak nincs jelentősége hogy milyen mappal lesz ez megoldva.</para>
        <programlisting>package sajatHasMap;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;



public class HashMap2&lt;K,V> implements Map&lt;K, V> {

	private final int  PRIME=7;
	ArrayList&lt;LinkidMap&lt;K,V>> rows;
	int size;
	
	private int hash(Object key) {
		int result;
		result =key.hashCode() % PRIME;
		
		return result; 
	}
	
	
	
	
	
	public HashMap2() {
		super();
		this.rows = new ArrayList&lt;LinkidMap&lt;K,V>>(PRIME);
		for(int index=0; index&lt;PRIME; index++) {
			rows.add(new LinkidMap&lt;K,V>());
		}
		this.size = 0;
	}





	@Override
	public int size() {
		// TODO Auto-generated method stub
		size=0;
		for(int index=0; index&lt;PRIME; index++) {
			size+=rows.get(index).size();
		}
		return size;
	}

	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		
		for (int index=0; index&lt;PRIME; index++) {
			if(! rows.get(index).isEmpty())
				return false;
		}
		
		return true; 
	}

	@Override
	public boolean containsKey(Object key) {
		// TODO Auto-generated method stub
		
		int index= hash(key);
		return rows.get(index).containsKey(key);
	
	}

	@Override
	public boolean containsValue(Object value) {
		// TODO Auto-generated method stub
		for(int index=0; index&lt;PRIME;index++) 
			if (rows.get(index).containsValue(value))
				return true;
		return false;
	}

	@Override
	public V get(Object key) {
		// TODO Auto-generated method stub
		int index= hash(key);
		return rows.get(index).get(key);
	}

	@Override
	public V put(K key, V value) {
		// TODO Auto-generated method stub
		int index= hash(key);
		return rows.get(index).put(key, value);
	}

	@Override
	public V remove(Object key) {
		// TODO Auto-generated method stub
		int index= hash(key);
		return rows.get(index).remove(key);
	}

	@Override
	public void putAll(Map&lt;? extends K, ? extends V> m) {
		// TODO Auto-generated method stub
		Set&lt;? extends K> keys = m.keySet();	
		for ( K key:keys) {
			this.put(key, m.get(key));			
		}
		
	}

	@Override
	public void clear() {
		// TODO Auto-generated method stub
		for (int index=0; index&lt;PRIME; index++)
			rows.get(index).clear();
	}

	@Override
	public Set&lt;K> keySet() {
		// TODO Auto-generated method stub
		Set&lt;K> keys =  new HashSet&lt;K>();
		for (int index=0; index&lt;PRIME; index++)
			keys.addAll(rows.get(index).keySet());
		return keys;
	}

	@Override
	public Collection&lt;V> values() {
		// TODO Auto-generated method stub
		Collection&lt;V> collection =new ArrayList&lt;>();
		for (int index=0; index&lt;PRIME; index++)
			collection.addAll(rows.get(index).values());
		return collection;
	}

	@Override
	public Set&lt;Entry&lt;K, V>> entrySet() {
		// TODO Auto-generated method stub
		Set&lt;Entry&lt;K, V>> result = new HashSet&lt;>();
		for (int index=0; index&lt;PRIME; index++)
			result.addAll(rows.get(index).entrySet());
		return result;
	}

}
</programlisting>
        <programlisting>package sajatHasMap;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;

public class LinkidMap&lt;K, V> implements Map&lt;K,V> {

	private Node&lt;K, V> root;
	
	public LinkidMap() {
		root = null;
	}
	
	private static class Node&lt;K,V> implements Map.Entry&lt;K, V>{
		
		private K key;
		private V value;
		private Node&lt;K, V> next;
		
		public Node(K key, V value, Node&lt;K, V> next) {
			super();
			this.key = key;
			this.value = value;
			this.next = next;
		} 
		
		 @Override
		public String toString() {
			// TODO Auto-generated method stub
			
			 String string ="Key: "+ getKey() +" "+ "Value: "+ getValue() ;
			 
			 return string; 
		}
		
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((key == null) ? 0 : key.hashCode());
			result = prime * result + ((value == null) ? 0 : value.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Node&lt;K,V> other = (Node&lt;K,V>) obj;
			if (key == null) {
				if (other.key != null)
					return false;
			} else if (!key.equals(other.key))
				return false;
			if (value == null) {
				if (other.value != null)
					return false;
			} else if (!value.equals(other.value))
				return false;
			return true;
		}
	
		public K getKey() {
			return key;
		}

		public void setKey(K key) {
			this.key = key;
		}

		public V getValue() {
			return value;
		}

		public V setValue(V value) {
			this.value = value;
			return  value;
		}

		public Node&lt;K, V> getNext() {
			return next;
		}

		public void setNext(Node&lt;K, V> next) {
			this.next = next;
		}
			
	}
	
	@Override
	public String toString() {
		Node&lt;K,V> currentNode = root;
		String string="LinkidMap [root]" ;
		while (currentNode != null) {
			string= string +" "+ currentNode.toString();
			currentNode=currentNode.getNext();
		}
		return string;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		Node&lt;K,V> current=root;
		while(current != null) {
			result = result +current.hashCode();
			current=current.next;
		}
		result = prime * result;
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		LinkidMap&lt;K,V> other = (LinkidMap) obj;
		if (root == null) {
			if (other.root != null)
				return false;
		} else {
			if (other.root == root)
				return true;//Ezz nincs tesztelve elméletileg nem is lehetne ilyen eset maximum a node setNext()-jével Null nál true-t add vissza
			if (this.root.key.getClass() != other.root.key.getClass())
				return false;
			if (this.root.value.getClass() != other.root.value.getClass())
				return false;
			Node&lt;K, V> current =root ;
			Node&lt;K, V> otherCurrent =other.root;
			boolean isItEquals = true; 
			while ((current.next != null)&amp;&amp;(otherCurrent.next != null) &amp;&amp; isItEquals) {
				isItEquals = current.equals(otherCurrent);
				current = current.next;
				otherCurrent =otherCurrent.next;
			}
			if ((current.next == null) &amp;&amp; (otherCurrent.next != null) || ((current.next != null) &amp;&amp; (otherCurrent.next == null) ) )
				return false;
			if (!isItEquals)
				return false;
		}
			
		return true;
	}

	@Override
	public int size() {
		int size = 0;	
		Node&lt;K,V> node =root;
		while (node != null) {
			
			node=node.getNext();
			size++;
			
		}
		return size;
	}

	@Override
	public boolean isEmpty() {
		
		if (root == null)
			return true;
		
		return false;
	}

	@Override
	public boolean containsKey(Object key) {
		// TODO Auto-generated method stub
		Node&lt;K,V> node =root;
		while (node != null) {
			if (node.getKey() == key) {
				return true;
			}else {
				node=node.getNext();
			}
		}
		
		return false;
	}

	@Override
	public boolean containsValue(Object value) {
		// TODO Auto-generated method stub
		
		Node&lt;K,V> node =root;
		while (node != null) {
			if (node.getValue() == value) {
				return true;
			}else {
				node=node.getNext();
			}
		}
		
		return false;
	}

	@Override
	public V get(Object key) {
		// TODO
		
		Node&lt;K,V> node =root;
		while (node != null) {
			if (node.getKey() == key) {
				return node.getValue();
			}else {
				node=node.getNext();
			}	
		}
		
		return null;
	}

	@Override
	public V put(K key, V value) {
		// TODO Auto-generated method stub
		if (!containsKey(key)) {
		Node&lt;K, V> node =new Node&lt;>(key,value,root);
		root = node;
		return value;
		}else {
			return null;
		}
	}

	@Override
	public V remove(Object key) {
		// TODO Auto-generated method stub első elem???
		Node&lt;K,V> befor =root;
		Node&lt;K,V> current=root;
		
		while (current != null) {
			if (current.getKey() == key) {
				befor.setNext(current.getNext());
				return current.getValue();
			} else {
				befor=current;
				current=current.getNext();
			}
			
		}
		
		return null;
	}

	@Override
	public void putAll(Map&lt;? extends K, ? extends V> m) {
		// TODO Auto-generated method stub
		//Sorendet nem tartja
		
		Set&lt;? extends K> keys = m.keySet();	
		for ( K key:keys) {
			this.put(key, m.get(key));			
		}
				
	}

	@Override
	public void clear() {
		// TODO Auto-generated method stub
		root=null;
	}

	@Override
	public Set&lt;K> keySet() {
		// TODO Auto-generated method stub
		Set&lt;K> keys =  new HashSet&lt;K>();
		Node&lt;K,V> currentNode =root;
		
		while (currentNode != null) {
			keys.add(currentNode.getKey());
			currentNode = currentNode.getNext();
		}
		
		return keys;
	}

	@Override
	public Collection&lt;V> values() {
		// TODO Auto-generated method stub
		
		Node&lt;K,V> currentNode =root;
		Collection&lt;V> collection =new ArrayList&lt;>();
		while (currentNode != null) {
			collection.add(currentNode.getValue());
			currentNode=currentNode.getNext();
		}
		return collection;
	}

	@Override
	public Set&lt;Entry&lt;K, V>> entrySet() {
		// TODO Auto-generated method stub
		Set&lt;Entry&lt;K, V>> result = new HashSet&lt;>();
		Node&lt;K,V> currentNode =root;
		while (currentNode != null) {
			result.add(currentNode);
			currentNode=currentNode.getNext();
		}
		
        return result;
	}
}</programlisting>
    </section>
	<section>
		<title>5. hét</title>
		<para>EPAM: It's gone. Or is it?</para>
		<para>
			<programlisting>public class BugousStuffProducer {
	private final Writer writer;

	public BugousStuffProducer(String outputFileName) throws IOException {
		writer = new FileWriter(outputFileName);
	}

	public void writeStuff() throws IOException {
		writer.write("Stuff");
	}

	@Override
	public void finalize() throws IOException {
		writer.close();
	}
}
</programlisting>
		</para>
		<para>Ha csak a writeStuff() eljárást hívjuk meg és a finalize()-t nem hívódik meg a program vége
			előtt akkor nem fog ki íródni a file-ba a bele írt szöveg. Alapból a garbage collector
			hívja a finalize()-t de amíg ez nem történik meg nem záródik le a file egyes esetekben
			még a program le futása végén se hívódik meg.</para>
		<para>Erre egy megoldást jelenthet ha implementálja az adott osztály az AutoCloseable
			interface-t és annak a close metódusában zárja le a filet.</para>
		<para>EPAM: Kind of equal</para>
		<programlisting>// Given
	String first = "...";
	String second = "...";
	String third = new String("...");
	// When
	boolean firstMatchesSecondWithEquals = first.equals(second);
	boolean firstMatchesSecondWithEqualToOperator = first == second;
	boolean firstMatchesThirdWithEquals = first.equals(third);
	boolean firstMatchesThirdWithEqualToOperator = first == third;
</programlisting>
		<para>A JVM optimalizációs célból fent tart egy string pool-t. Ha literálként hozzuk létre a
			string-et akkor először végig nézi a pool-ban hogy már létezik e az adott string ha igen
			akkor csak az adott string referenciájával tér vissza ha nem létezik létre hozza és bele
			rakja a pool-ba.</para>
		<para>Ezzel szembe ha a new operátorral végezzük ell a string létrehozását akkor mindig egy
			új objektum jön létre.</para>
		<para>Ebből következik az is hogy a first==second az true-val tér vissza mert ténylegesen
			ugyan azt az objektumot kapták meg a JVM-től, míg a Third.-nél új objektum jött létre
			ugyan azzal a tartalommal</para>
		<para>EPAM: Java GC</para>
		<para>Serial Garbage Collector</para>
		<para>Ez a GC legegyszerűbb megvalósítása. Alapvetően egyszálas környezetre tervezték. Ez a
			GC megvalósítás fagyasztja az összes alkalmazásszálat, amikor fut. Egyetlen szálat
			használ a garbage collection-höz. Ezért nem jó ötlet több szálon futó alkalmazásokban
			használni, például szerver környezetben.</para>
		<para>Parallel Garbage Collector</para>
		<para>Ez a GC a z előzővel ellentétben több szálon fut de ugyan úgy meg állítja az
			alkalmazást mint az előző. Be alíthatjuk a szálak számát, az rendelkezésére álló időt,
			maximum throughput-ot és a maximum heap footprintet.</para>
		<para>CMS Garbage Collector</para>
		<para>Az előzőhöz hasonlóan több szálat használ. Megkeresi é meg jelöli a heap memory-ban a
			törlendő objektumokat majd ki törli őket. olyan alkalmazásoknál célszerű használni
			melyek több kisebb meg állást preferálnak egy hosszabb helyet és képesek CPU időt
			biztositani a GC-nek.</para>
		<para>G1 Garbage Collector</para>
		<para>Arra tervezték hogy több CPU-s környezetbn nagy memória terület mellet dolgozzon jól.
			Felosztja egyenlő részekre a memóriát és párhuzamosan gyűjt belőlük. Kettő fázisa van
			Marking és Sweeping. Mindig annál a memória résznél kezdi a gyűjtést ami a leginkább
			üres </para>
		<para>Epsilon Garbage Collector</para>
		<para>Lefoglalja a memóriát a programnak de nem gyűjt szemetet ha tesztelni akarjuk a
			programot hogy menyi memóriát használ egy jóeszköz vagy ha ki akarjuk sajtolni a legjobb
			teljesítményt az adott programból. </para>
		<para>Z garbage collector</para>
		<para>A ZGC minden költséges munkát egyidejűleg végez, anélkül, hogy 10 ms-nál hosszabb
			időre leállítaná az alkalmazásszálak végrehajtását, ami alkalmassá teszi alacsony
			késleltetést igénylő alkalmazásokhoz és / vagy nagyon nagy heap memorit használó
			alkalmazásokhoz. Az Oracle dokumentációja szerint több terabájtos memóriát képes
			kezelni. A Z szemétgyűjtő a szálaiban végzi ciklusait. Átlagosan 1 ms-ig szünetelteti az
			alkalmazást. A G1 és a Parallel kollektorok átlagosan nagyjából 200 ms-ot tesznek
			ki.</para>
		<para>Shenandoah Garbage Collector</para>
		<para>Shenandoah memóriaterületeket használ annak kezelésére, hogy mely objektumok már nincsenek
			használatban, melyek élnek és készek a tömörítésre. Shenandoah emellett továbbít mutatót
			minden kupac objektumhoz, és az objektumhoz való hozzáférés ellenőrzésére használja.
			Shenandoah tervezése párhuzamos CPU-ciklusokat és helyet biztosít a szünetidő
			javítására. A továbbító mutató megkönnyíti az objektumok mozgatását, de az agresszív
			mozgások azt jelentik, hogy Shenandoah több memóriát használ, és több párhuzamos munkát
			igényel, mint más GC-k. De a rendkívüli munkát a környezet rövid megállításaival
			végzi.</para>
		<para>out of memory</para>
		<para>Lehetséges ha elkapjuk az errot valahol és tudunk felszabadítani memóriát de nem
			lehetünk benne biztosak hogy a JVM milyen álapotban van éppen és menyire tudjuk vissza
			álitani. Jobb eljárás lenne inkább csak meg próbálni lezárni az erőforrásokat esetleg ki
			loggolni a hibát kiváltó tényzőket</para>
	</section>
	<section>
		<title>6. hét</title>
		<para>EPAM:  Mátrix szorzás Stream API val</para>
		<programlisting>public static int[][] matrixszorzas(int[][] a, int[][] b) {

		if (a[0].length == b.length) {
			int bNumberOfCloumns = b[0].length; // oszlopok száma
			int bNumberOfRows = b.length; // szorzások száma

			int[][] c = Arrays.stream(a)// c.length-szer fut le
					.map(r -> IntStream.range(0, bNumberOfCloumns)
							.map(i -> IntStream.range(0, bNumberOfRows).map(j -> r[j] * b[j][i]).sum()).toArray())
					.toArray(int[][]::new);
			return c;
		} else {

			return null;
		}
	}</programlisting>
		<para>Egy m × t-s A és egy t × nes B mátrix szorzatán azt az AB-vel jelölt m × n-es C
			mátrixot értjük,</para>
		<para>A mátrix i-edik sorának és a B mátrix j-edik oszlopának skaláris szorzata, azaz cij =
			ai∗ · b∗j .</para>
		<para>EPAM: Refactoring</para>
		<programlisting>public class LegacyRefactoring {
	private Calculator creatCalculators() {
		return number -> number * number;
	}

	private Runnable creatRunnable() {
		return () -> System.out.println("Runnable!");
	}
	
	private  Consumer&lt;Integer> creatConsumer()  {
		return number -> System.out.println(number);
				
	}

	public void legacy() {

		Runnable runnable = creatRunnable();
		runnable.run();

		Calculator calculator = creatCalculators();

		Integer result = calculator.calculate(3);
		System.out.println("Calculation result: " + result);

		List&lt;Integer> inputNumbers = Arrays.asList(1, null, 3, null, 5);
		List&lt;Integer> resultNumbers = new ArrayList&lt;>();
		resultNumbers = inputNumbers.stream()
				.filter(x -> x != null)
				.map(x -> calculator.calculate(x))
				.collect(Collectors.toList());

		Consumer&lt;Integer> method =creatConsumer();
		System.out.println("Result numbers: ");
		resultNumbers.forEach(method);

		Formatter formatter = creatFormatter();
		
		System.out.println("Formatted numbers: " + formatter.format(resultNumbers));
	}
	
	private Formatter creatFormatter() {
		return numbers -> numbers.stream()
				.map(x -> String.valueOf(x))
				.collect(Collectors.joining());
	}</programlisting>
		<para>EPAM: LinkedList vs ArrayList</para>
		<para>LinkidListet </para>
		<para>LinkidList-tet akkor érdemes használni ha gyorsan változik a tárolt adatok mennyisége
			vagy sok törlés beszúrás történik ellenben a gyors hozzáférést nem támogatja végig kel
			menni az egész láncon a keresendő elemig ezzel szemben az arrayList-nél közvetlen
			hozzáférést biztosit így gyorsabb az adattok olvasása de ha törlünk akkor vagy
			"lyukakat" hagyunk a memóriában vagy átlagosan az elemek felét másolnunk kell. Ha pedig
			bővítjük a listát és ki futunk az előzetesen lefoglalt területből akkor a teljes listát
			új helyre kell másolni. Akkor érdemes használni ha előre tudjuk a tárolni kívánt adatok
			mennyiséget (ilyenkor már a konstruktorban meg adható a tárolandó elemek száma) vagy
			fontosabb az adatok gyors elérése.</para>
		<programlisting>package linkidlistvsarraylist;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Main {
	 

	static final int NUMBER_OF_ELEMET=200000;

	static void addingElementsToArrayList() {
		List&lt;Integer> list = new ArrayList&lt;>();
		long time = System.currentTimeMillis();
		for (int i = 0; i &lt; NUMBER_OF_ELEMET; i++)
			list.add(i);
		System.out.println("Adding "+NUMBER_OF_ELEMET +" elemet to arrayList: " + (System.currentTimeMillis() - time));
	}
	static void removeElementFromArrayList() {
		List&lt;Integer> list = new ArrayList&lt;>();
		for (int i = 0; i &lt; NUMBER_OF_ELEMET; i++)
			list.add(i);
		long time = System.currentTimeMillis();
		while(list.size()!=0)
			list.remove(list.size()/2);
		System.out.println("Removing "+NUMBER_OF_ELEMET +" elemet from arrayList: " + (System.currentTimeMillis() - time));
	}
	
	static void getElementFromArrayList() {
		List&lt;Integer> list = new ArrayList&lt;>();
		for (int i = 0; i &lt; NUMBER_OF_ELEMET; i++)
			list.add(i);
		long time = System.currentTimeMillis();
		for (int i = 0; i &lt; NUMBER_OF_ELEMET; i++)
			list.get(i);
		System.out.println("Geting "+NUMBER_OF_ELEMET +" elemet from arrayList: " + (System.currentTimeMillis() - time));
	}
	
	static void addingElementsToLinkedList() {
		long time = System.currentTimeMillis(); 
		List&lt;Integer> list = new LinkedList&lt;>();
		for (int i = 0; i &lt; NUMBER_OF_ELEMET; i++)
			list.add(i);
		System.out.println("Adding "+NUMBER_OF_ELEMET +" elemet to LinkedList: " + (System.currentTimeMillis() - time));
	}
	
	static void removeElementFromLinkedList() {
		List&lt;Integer> list = new LinkedList&lt;>();
		for (int i = 0; i &lt; NUMBER_OF_ELEMET; i++)
			list.add(i);
		long time = System.currentTimeMillis();
		while(list.size()!=0)
			list.remove(list.size()/2);
		System.out.println("Removing "+NUMBER_OF_ELEMET +" elemet from LinkedList: " + (System.currentTimeMillis() - time));
	}
	
	static void getElementFromLinkedList() {
		List&lt;Integer> list = new LinkedList&lt;>();
		for (int i = 0; i &lt; NUMBER_OF_ELEMET; i++)
			list.add(i);
		long time = System.currentTimeMillis();
		for (int i = 0; i &lt; NUMBER_OF_ELEMET; i++)
			list.get(i);
		System.out.println("geting "+NUMBER_OF_ELEMET +" elemet from LinkedList: " + (System.currentTimeMillis() - time));
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		addingElementsToArrayList();
		addingElementsToLinkedList();
		removeElementFromArrayList();
		removeElementFromLinkedList();
		getElementFromArrayList();
		getElementFromLinkedList();
	}

}
</programlisting>
		<para>kimenet:</para>
		<programlisting>Adding 200000 elemet to arrayList: 23
Adding 200000 elemet to LinkedList: 26
Removing 200000 elemet from arrayList: 1219
Removing 200000 elemet from LinkedList: 31024
Geting 200000 elemet from arrayList: 3
geting 200000 elemet from LinkedList: 28911
</programlisting>
	</section>
	<section>
		<title>7.hét</title>
		<para>EPAM: XML
			feldolgozás<programlisting>import org.xml.sax.SAXException;

import javax.xml.parsers.ParserConfigurationException;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;

public class XmlMapPlotter {
    public static void main(String[] args) throws IOException, SAXException, ParserConfigurationException {
    	XmlReader reader = new SaxXmlReader(new FileInputStream(args[0]));
        List&lt;City> cities = reader.getCities();
        MapImage image = new SvgMapImage(800, 600);
        cities.forEach(city -> city.plot(image));
        image.save(new FileWriter(args[1]));
    }
}
</programlisting><programlisting>import java.util.List;

public interface XmlReader {
    List&lt;City> getCities();
}
</programlisting><programlisting>import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.IOException;
import java.io.InputStream;
import java.util.LinkedList;
import java.util.List;
import java.util.function.Consumer;

public class SaxXmlReader extends DefaultHandler implements XmlReader {

    private double currentXCoordinate;
    private double currentYCoordinate;
    private String currentState;

    private Consumer&lt;String> actionOnCharacters = c -> {
    };

    private List&lt;City> result = new LinkedList&lt;>();

    public SaxXmlReader(InputStream input) throws ParserConfigurationException, SAXException, IOException {
        SAXParser parser = SAXParserFactory.newInstance().newSAXParser();
        parser.parse(input, this);
    }

    @Override
    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
        if (qName.equalsIgnoreCase("coordinateX")) {
            actionOnCharacters = c -> currentXCoordinate = Double.parseDouble(c);
        }
        if (qName.equalsIgnoreCase("coordinateY")) {
            actionOnCharacters = c -> currentYCoordinate = Double.parseDouble(c);
        }
        if (qName.equalsIgnoreCase("state")) {
            actionOnCharacters = c -> currentState = c;
        }
    }

    @Override
    public void endElement(String uri, String localName, String qName) throws SAXException {
        if (qName.equalsIgnoreCase("city")) {
            result.add(new City(currentXCoordinate, currentYCoordinate, currentState));
        }
    }

    @Override
    public void characters(char[] ch, int start, int length) throws SAXException {
        actionOnCharacters.accept(new String(ch, start, length));
        actionOnCharacters = c -> {
        };
    }

    @Override
    public List&lt;City> getCities() {
        return result;
    }
}</programlisting><programlisting>import java.io.Writer;

public interface MapImage {
    void addPoint(double x, double y);

    void save(Writer targetStream);

	void addPoint(double yCoordinate, double xCoordinate, String state);
}
</programlisting><programlisting>import org.apache.batik.dom.GenericDOMImplementation;
import org.apache.batik.svggen.SVGGraphics2D;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;

import java.awt.*;
import java.io.Writer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

public class SvgMapImage implements MapImage {

    SVGGraphics2D svgGenerator;

       
    public Map&lt;String,Color> colors;
    
    public SvgMapImage(int canvasWidth, int canvasHeight) {
        // Get a DOMImplementation.
        DOMImplementation domImpl = GenericDOMImplementation.getDOMImplementation();
        // Create an instance of org.w3c.dom.Document.
        String svgNS = "http://www.w3.org/2000/svg";
        Document document = domImpl.createDocument(svgNS, "svg", null);
        // Create an instance of the SVG Generator.
        svgGenerator = new SVGGraphics2D(document);
        svgGenerator.setSVGCanvasSize(new Dimension(canvasWidth, canvasHeight));
        colors = new HashMap&lt;>();
        }
   
    @Override
    public void addPoint(double x, double y) {
        svgGenerator.fillOval((int) x, (int) y, 2, 2);
    }

    @Override
    public void save(Writer targetStream) {
        try {
            svgGenerator.stream(targetStream);
        } catch (Exception e) {
            throw new RuntimeException("Failed to write image", e);
        }
    }
    
    @Override
    public void addPoint(double x, double y, String state) {
    	if (!colors.containsKey(state)) {
    		
    		Color c =new Color(new Random().nextInt(255),new Random().nextInt(255),new Random().nextInt(255));
    		while (colors.containsValue(c))
    			c =new Color(new Random().nextInt(255),new Random().nextInt(255),new Random().nextInt(255));
    		colors.put(state, c);
    		
    	}
    	
    	
    	Color c =colors.get(state);
    	svgGenerator.setColor(c);
    	addPoint(x, y);
    }
}</programlisting><programlisting>public class City {
    private double xCoordinate;
    private double yCoordinate;
    private String state;

    public City(double xCoordinate, double yCoordinate, String state) {
        this.xCoordinate = xCoordinate;
        this.yCoordinate = yCoordinate;
        this.state = state;
    }

    public void plot(MapImage map) {
        map.addPoint(this.yCoordinate, this.xCoordinate, this.state);
    }
}
</programlisting></para>
		<para>EPAM: ASCII Art</para>
		<programlisting>package main;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import javax.imageio.ImageIO;

import Printer.Printer;

public class Main {
	public static void main(String[] args) throws IOException {
		String imageName = args[0];
		String textFileName = args.length != 2 ? null : args[1];
		OutputStream outputStream = textFileName == null ? System.out : new FileOutputStream(textFileName);
		BufferedImage image = ImageIO.read(new File(imageName));

		new Printer(outputStream, image).print();
	}
}</programlisting>
		<programlisting>package Printer;

import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.OutputStream;

public class Printer {
	private static final char[] ASCII_PIXELS = { '$', '#', '*', ':', '.', ' ' };
	private static final byte[] NEW_LINE = "\n".getBytes();

	private OutputStream outputStream;
	private BufferedImage image;

	public Printer(OutputStream outputStream, BufferedImage image) {
		this.outputStream = outputStream;
		this.image = image;
	}

	public void print() throws IOException {
		for (int i = 0; i &lt; image.getHeight(); i++) {
			for (int j = 0; j &lt; image.getWidth(); j++) {
				outputStream.write(getAsciiChar(image.getRGB(j, i)));
			}
			outputStream.write(NEW_LINE);
		}
	}

	public static char getAsciiChar(int pixel) {
		return getAsciiCharFromGrayScale(getGreyScale(pixel));
	}

	public static int getGreyScale(int argb) {
		int red = (argb >> 16) &amp; 0xff;
		int green = (argb >> 8) &amp; 0xff;
		int blue = (argb) &amp; 0xff;
		return (red + green + blue) / 3;
	}

	public static char getAsciiCharFromGrayScale(int greyScale) {
		return ASCII_PIXELS[greyScale / 51];
	}

}
</programlisting>
		<para><inlinemediaobject>
				<imageobject>
					<imagedata fileref="emoji.png"/>
				</imageobject>
			</inlinemediaobject></para>
		<para>EPAM:</para>
		<para>Titkos üzenet, száll a gépben!</para>
		<programlisting>package hu.unideb.prog2.caesar;

import hu.unideb.prog2.caesar.coder.Coder;
import hu.unideb.prog2.caesar.writer.Writer;

public class Main {
	public static void main(String[] args) throws Exception {	
		System.out.println("Running");
		Writer writer = new Writer(args[0]);
		Coder coder =new Coder(System.in, writer);
		
		coder.coding();
		coder.close();
		System.out.println("exit");
	}
}
</programlisting>
		<programlisting>package hu.unideb.prog2.caesar.writer;

import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStream;

public class Writer extends OutputStream {

	private FileWriter filewriter;
	
	public Writer(String fileName) throws IOException {
		super();
		this.filewriter = new FileWriter(fileName);
	}

	@Override
	public void write(int b) throws IOException {
		// TODO Auto-generated method stub
		filewriter.write(b);
		
	}
	
	@Override
	public void close() throws IOException {
		filewriter.close();
	}
	

}
</programlisting>
		<programlisting>package hu.unideb.prog2.caesar.coder;

import java.util.List;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Scanner;

public class Coder implements AutoCloseable {

	private Scanner scanner;
	private OutputStream output;

	public Coder(InputStream input, OutputStream output) {
		super();
		if (input == null) {
			throw new NullPointerException("Input is a mandatory parameter");
		}
		if (output == null) {
			throw new NullPointerException("Output is a mandatory parameter");
		}
		this.scanner = new Scanner(input);
		this.output = output;
	}

	public void coding() throws IOException {

		String line;

		while (scanner.hasNextLine()) {
			line = scanner.nextLine();
			if (line.equals("!exit")) {
				break;
			}
			List&lt;Integer> a = new ArrayList&lt;Integer>();
			
			
			for(int i =0;i&lt; line.getBytes().length; i++) {
				a.add((int) line.getBytes()[i]);
			}
			//System.err.println(a.size());
		
			a.stream().forEach(x->{
				try {
					output.write(x+1);
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			});
			output.write(10);
			//output.write(13);
		}
			
		

	}

	public void close() throws Exception {
		// TODO Auto-generated method stub
		scanner.close();
		output.close();

	}

}
</programlisting>
	</section>
	<section>
		<title>8. hét</title>
		<para>Port scan</para>
		<programlisting>public class KapuSzkenner {
    
    public static void main(String[] args) {
        
        for(int i=0; i&lt;1024; ++i)
            
            try {
                
                java.net.Socket socket = new java.net.Socket(args[0], i);
                
                System.out.println(i + " figyeli");
                
                socket.close();
                
            } catch (Exception e) {
                
                System.out.println(i + " nem figyeli");
                
            }
    }
    
}</programlisting>
		<para>Ebben a példában arra használjuk a kivétel kezelést hogy meg tudjuk állapitani hogy a
			gépünk milyen portokat figyel ha létre tudja hozni a portot akkor figyeli ha nem tudja
			létre hozni akkor nem figyeli</para>
		<para>Azt meg szeretném említeni hogy a construktora socket-nek több okból is dobhat
			kivételt(UnknownHostException - if the IP address ofthe host could not be determined.
			IOException - if an I/O error occurs when creating the socket. SecurityException - if a
			security manager exists and its checkConnect method doesn't allow the operation.
			IllegalArgumentException - if the port parameter is outsidethe specified range of valid
			port values, which is between0 and 65535, inclusive.) ebből kifolyólag a program nem
			minden körülmény közt működik tökéletesen. Megoldás lehet hogy ha csak az I/OExeptiont
			akarjuk elkapni</para>
		<para>EPAM: DI</para>
		<programlisting>package hu.unideb.prog2.di.annotation;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
public @interface Bean {
}
</programlisting>
		<programlisting>package hu.unideb.prog2.di.defaultcontext;

import hu.unideb.prog2.di.Context;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Objects;

public class BeanDefinition {

    private Class&lt;?> beanType;
    private Method factoryMethod;

    public BeanDefinition(Class&lt;?> beanType, Method factoryMethod) {
        this.beanType = beanType;
        this.factoryMethod = factoryMethod;
    }

    public Object createBean(Context context) {
        Class&lt;?>[] parameterTypes = factoryMethod.getParameterTypes();
        Object[] dependencies = Arrays.stream(parameterTypes)
                .map(context::getBeanForType)
                .toArray();
        try {
            return factoryMethod.invoke(null, dependencies);
        } catch (IllegalAccessException|InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }

    public Class&lt;?> getBeanType() {
        return beanType;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        BeanDefinition that = (BeanDefinition) o;
        return Objects.equals(beanType, that.beanType) &amp;&amp;
                Objects.equals(factoryMethod, that.factoryMethod);
    }

    @Override
    public int hashCode() {
        return Objects.hash(beanType, factoryMethod);
    }
}</programlisting>
		<programlisting>package hu.unideb.prog2.di.defaultcontext;

import java.util.List;

public interface BeanDefinitionLoader {
    List&lt;BeanDefinition> loadBeanDefinitions();
}
</programlisting>
		<programlisting>package hu.unideb.prog2.di.defaultcontext;

import hu.unideb.prog2.di.annotation.Bean;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class ConfigurationClassBasedBeanDefinitionLoader implements BeanDefinitionLoader {

    private final Class&lt;?> configurationClass;

    public ConfigurationClassBasedBeanDefinitionLoader(Class&lt;?> configurationClass) {
        this.configurationClass = configurationClass;
    }

    @Override
    public List&lt;BeanDefinition> loadBeanDefinitions() {
        return Arrays.stream(configurationClass.getDeclaredMethods())
                .filter(this::shouldCreateBeanDefinitionForMethod)
                .map(this::createBeanDefinition)
                .collect(Collectors.toList());
    }

    private boolean shouldCreateBeanDefinitionForMethod(Method method) {
        boolean isAnnotatedWithBean = Arrays.stream(method.getAnnotations())
                .anyMatch(annotation -> Bean.class.equals(annotation.annotationType()));
        return isAnnotatedWithBean &amp;&amp; Modifier.isStatic(method.getModifiers());
    }

    private BeanDefinition createBeanDefinition(Method method) {
        return new BeanDefinition(method.getReturnType(), method);
    }
}
</programlisting>
		<programlisting>package hu.unideb.prog2.di.defaultcontext;

import hu.unideb.prog2.di.Context;

import java.util.*;

public class DefaultContext implements Context {

    Map&lt;BeanDefinition, Optional&lt;Object>> beanDefinitionToObjectMap;

    public DefaultContext(BeanDefinitionLoader definitionLoader) {
        beanDefinitionToObjectMap = new HashMap&lt;>();
        definitionLoader.loadBeanDefinitions().forEach(def -> beanDefinitionToObjectMap.put(def, Optional.empty()));
    }

    @Override
    public &lt;T> T getBeanForType(Class&lt;T> expectedBeanType) {
        Map.Entry&lt;BeanDefinition, Optional&lt;Object>> beanDefinitionEntry = beanDefinitionToObjectMap.entrySet().stream()
                .filter(definition -> definition.getKey().getBeanType().equals(expectedBeanType))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("No bean found for type " + expectedBeanType.getCanonicalName()));
        if (beanDefinitionEntry.getValue().isEmpty()) {
            beanDefinitionEntry.setValue(Optional.of(beanDefinitionEntry.getKey().createBean(this)));
        }
        return (T) beanDefinitionEntry.getValue().get();
    }
}
</programlisting>
		<programlisting>package hu.unideb.prog2.di;

public interface Context {

    int someValue =10;

    &lt;T> T getBeanForType(Class&lt;T> type);
}
</programlisting>
		<programlisting>public class Main {

	public static void main(String[] args) {
		Context applicationContext = new DefaultContext(
				new ConfigurationClassBasedBeanDefinitionLoader(WebshopAppConfiguration.class));
		try (UserInteractionController controller = applicationContext.getBeanForType(UserInteractionController.class)) {
			controller.handleUserInputs();
		} catch (Exception e) {
			e.printStackTrace();
		};
	}

}</programlisting>
		<para>EPAM: Kivételkezelés</para>
		<programlisting>public static void test(Object input)  {
		try {
			System.out.println("Try");
			if (input instanceof Float) {
				throw new ChildExeption();
			} else if (input instanceof String) {
				throw new ParentExeption();
			} else {
				throw new RuntimeException();
			}

		} catch (ChildExeption e) {
			// TODO Auto-generated catch block
			System.out.println("Child Exeption is caught!");
			if (e instanceof ParentExeption) {
				throw new ParentExeption();
			}
		} catch (ParentExeption e) {
			// TODO Auto-generated catch block
			System.out.println("parent Exeption is Caught!");
			System.exit(1);
		} catch (Exception e) {
			System.out.println("exeption is caught!");
		} finally {
			// TODO: handle finally clause
			System.out.println("Finally!");
		}
	}</programlisting>
		<para>Bemenet 1f </para>
		<para>Kimenet:</para>
		<programlisting>Exception in thread "main" Try
Child Exeption is caught!
Finally!
kivetelkezeles.ParentExeption
	at kivetelkezeles.TestKivetelkezeles.test(TestKivetelkezeles.java:21)
	at kivetelkezeles.TestKivetelkezeles.main(TestKivetelkezeles.java:36)</programlisting>
		<para>A Try az mindenképpen ki íródik függetlenül a bementtől</para>
		<para>A Child Exeption is caught! azért íródik ki mert az input a z float az első if-ből
			dobódik egy ChildExeption ami majd a megfelelő catch-ben el lesz kapva amiből dobódik
			egy ParentExeption de az előtt még le fut a finally mivel a finally még akkor is lefut
			ha nem várt kivétel jelentkezik valahol ez fontos a resourcing recovering-hez.</para>
		<para>Ezután pedig a JVM elkapja az ez előtt dobot ParentExeption-t</para>
		<para>Bemenet String</para>
		<para>Kimenet:</para>
		<programlisting>Try
parent Exeption is Caught!</programlisting>
		<para>A Try az mindenképpen ki íródik függetlenül a bementtől</para>
		<para>Ezután az első if ben dobódik egy ParentExeption amit elkap a megfelelő catch ami ki
			írja a második sort:parent Exeption is Caught!</para>
		<para>De a finally nem fog lefutni mert a catch ben termináljuk a programot így véget ér az
			előt a program futása hogy a finally lefuthatna</para>
		<para>Bemenet null</para>
		<para>Kimenet:</para>
		<programlisting>Try
exeption is caught!
Finally!</programlisting>
		<para>A Try az mindenképpen ki íródik függetlenül a bementtől</para>
		<para>Mivel null-lal let hívva így az ifben az else ágról fog dobódni egy RuntimeException
			amit az utolsó catch kapja el ami kiírja második sort: exeption is caught!</para>
		<para>Majd pedig lefut a finally is ami miatt kiíródik a:Finally!</para>
	</section>
	<section>
		<title>9. hét</title>
		<para>EPAM: Back To The Future </para>
		<programlisting>package het9valami;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class FutureChainingExercise {
	private static ExecutorService executorService = Executors.newFixedThreadPool(2);
	private static Logger LOGGER = LoggerFactory.getLogger(FutureChainingExercise.class);

	public static void main(String[] args) {
		long time=System.currentTimeMillis();
		
		CompletableFuture&lt;String> longTask = CompletableFuture.supplyAsync(() -> {
			LOGGER.info("longTask is started at {}",System.currentTimeMillis()-time);
			sleep(1000);
			LOGGER.info("longTask is ready at {}",System.currentTimeMillis()-time);
			return "Hello";
		}, executorService);

		CompletableFuture&lt;String> shortTask = CompletableFuture.supplyAsync(() -> {
			LOGGER.info(" shortTask is started at {}",System.currentTimeMillis()-time);
			sleep(500);
			LOGGER.info(" shortTask is ready at {}",System.currentTimeMillis()-time);
			return "Hi";
		}, executorService);

		CompletableFuture&lt;String> mediumTask = CompletableFuture.supplyAsync(() -> {
			LOGGER.info("mediumTask is started at {}",System.currentTimeMillis()-time);
			sleep(750);
			LOGGER.info("mediumTask is ready at {}",System.currentTimeMillis()-time);
			return "Hey";
		}, executorService);
		
		LOGGER.info("Begining");
		CompletableFuture&lt;String> result = longTask.applyToEitherAsync(shortTask, String::toUpperCase, executorService);
		
		
		result = result.thenApply(s -> s + " World");

		CompletableFuture&lt;Void> extraLongTask = CompletableFuture.supplyAsync(() -> {
			LOGGER.info("extraLongTask is started at {}",System.currentTimeMillis()-time);
			sleep(1500);
			LOGGER.info("extraLongTask is ready at {}",System.currentTimeMillis()-time);
			return null;
		}, executorService);
		result = result.thenCombineAsync(mediumTask, (s1, s2) -> s2 + ", " + s1, executorService);
		LOGGER.info("firrst getNow at {}",System.currentTimeMillis()-time);
		System.out.println(result.getNow("Bye"));
		sleep(1500);
		LOGGER.info("second getNow at {}",System.currentTimeMillis()-time);
		System.out.println(result.getNow("Bye"));
		// Hey, HELLO Word

		result.runAfterBothAsync(extraLongTask, () -> System.out.println("After both!"), executorService);

		result.whenCompleteAsync((s, throwable) -> System.out.println("Complete: " + s), executorService);

		executorService.shutdown();
		LOGGER.info("shutdown");
	}

	// Eredeti implementáció(nekem ezzel hibát dobott):
//	/** * * @param sleeptime sleep time in milliseconds */
//	private static void sleep(int sleeptime) {...}
//	
	// Saját impementáció(Szerintem ennek kéne ott lenni)
	/**
	 * * * @param sleeptime sleep time in milliseconds
	 * 
	 * @throws InterruptedException
	 */
	private static void sleep(int sleeptime) {
		try {
			Thread.sleep(sleeptime);
			LOGGER.info("waiting  {}",sleeptime);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	
}</programlisting>
		<para>Kimenet Logger nélkül:</para>
		<programlisting>Bye
Hey, HELLO World
Complete: Hey, HELLO World</programlisting>
		<para>Kimenet
			Loggerrel:<programlisting>[main] INFO backToTheFuture.FutureChainingExercise - Begining
[pool-1-thread-1] INFO backToTheFuture.FutureChainingExercise - longTask is started at 11
[pool-1-thread-2] INFO backToTheFuture.FutureChainingExercise -  shortTask is started at 12
[main] INFO backToTheFuture.FutureChainingExercise - firrst getNow at 25
Bye
[pool-1-thread-2] INFO backToTheFuture.FutureChainingExercise - waiting  500
[pool-1-thread-2] INFO backToTheFuture.FutureChainingExercise -  shortTask is ready at 518
[pool-1-thread-2] INFO backToTheFuture.FutureChainingExercise - mediumTask is started at 519
[pool-1-thread-1] INFO backToTheFuture.FutureChainingExercise - waiting  1000
[pool-1-thread-1] INFO backToTheFuture.FutureChainingExercise - longTask is ready at 1018
[pool-1-thread-1] INFO backToTheFuture.FutureChainingExercise - extraLongTask is started at 1018
[pool-1-thread-2] INFO backToTheFuture.FutureChainingExercise - waiting  750
[pool-1-thread-2] INFO backToTheFuture.FutureChainingExercise - mediumTask is ready at 1270
[main] INFO backToTheFuture.FutureChainingExercise - waiting  1500
[main] INFO backToTheFuture.FutureChainingExercise - second getNow at 1526
Hey, HELLO World
[main] INFO backToTheFuture.FutureChainingExercise - shutdown
Complete: Hey, HELLO World
[pool-1-thread-1] INFO backToTheFuture.FutureChainingExercise - waiting  1500
[pool-1-thread-1] INFO backToTheFuture.FutureChainingExercise - extraLongTask is ready at 2518
</programlisting></para>
		<para>Az első Bye azért kerül ki iratásra mert abban az idő pilanatban még nincs kész egyik
			task sem.</para>
		<para>Hey, Hello World: 1500milliseconds várakozás után megint meg lesz híva a getNow ekkor
			ra készen van a ShortTask a Madium Task és a longTask is de Short és a Medium ugyan azon
			a szálon lett végre hajtva ezért a mediummot fogja meg kapni.</para>
		<para>Complete: Hey, HELLO World: itt meg várja hogy be fejeződjön minden task és akkor fog
			ki iratni</para>
		<para>EPAM: AOP</para>
		<programlisting>package com.epam.training;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Custom performance test marker annotation.
 * Execution time for every method marked with this annotation will be collected and printed to stdout.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface CustomTimer {
}

</programlisting>
		<programlisting>package com.epam.training;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Service;
import org.springframework.util.StopWatch;

/**
 * Custom aspect for collecting execution time for methods annotated with {@link CustomTimer}.
 */
@Aspect
@Service
public class CustomTimerAspect {

    @Around("@annotation(com.epam.training.CustomTimer)")
    public Object timeAnnotatedMethod(ProceedingJoinPoint pjp) throws Throwable {
        // start stopwatch
        StopWatch stopWatch = new StopWatch(pjp.getTarget().toString());
        stopWatch.start();

        Object retVal = pjp.proceed();

        // stop stopwatch
        stopWatch.stop();

        System.out.println("Execution time for " + pjp.getTarget().toString() + ": " + stopWatch.getTotalTimeMillis() + " ms");

        return retVal;
    }

}
</programlisting>
		<programlisting>package com.epam.training;

import org.springframework.stereotype.Service;

@Service
public class ExampleService {

    @CustomTimer
    public void exampleMethodToTime() throws InterruptedException {
        System.out.println("Testee start!");

        Thread.sleep(1000);

        System.out.println("Testee end!");
    }

}

</programlisting>
		<programlisting>package com.epam.training;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@SpringBootApplication
@EnableAspectJAutoProxy
public class MainApplication {

    public static void main(String[] args) {
        SpringApplication.run(MainApplication.class, args);
    }

    @Bean
    public CommandLineRunner commandLineRunner(ApplicationContext ctx) {
        return args -> ctx.getBean(ExampleService.class).exampleMethodToTime();
    }

}

</programlisting>
		<para>kimenet:<programlisting>
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.3.3.RELEASE)

2020-12-07 13:52:33.810  INFO 14656 --- [           main] com.epam.training.MainApplication        : Starting MainApplication on DESKTOP-72JQOBP with PID 14656 (C:\Users\HP\Documents\GitHub\epam-deik-prog2\week-9\aop-performance-test\target\classes started by HP in C:\Users\HP\Documents\GitHub\epam-deik-prog2\week-9\aop-performance-test)
2020-12-07 13:52:33.818  INFO 14656 --- [           main] com.epam.training.MainApplication        : No active profile set, falling back to default profiles: default
2020-12-07 13:52:35.900  INFO 14656 --- [           main] com.epam.training.MainApplication        : Started MainApplication in 3.251 seconds (JVM running for 4.775)
Testee start!
Testee end!
Execution time for com.epam.training.ExampleService@460510aa: 32888 ms
</programlisting></para>
		<para>AspectJ:<programlisting>package proba1;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Account account =new Account();
		
		account.withdraw(10);

	}

}
</programlisting><programlisting>package proba1;

public class Account {
	int balance = 20;

	public boolean withdraw(int amount) {
		
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		if (balance &lt; amount) {
			return false;
		}
		//System.out.println("working");
		balance = balance - amount;
		return true;
	}

}
</programlisting><programlisting>package proba1;

public aspect AccountAspect {
	 final int MIN_BALANCE = 10;

	    pointcut callWithDraw(int amount, Account acc) : 
	     call(boolean Account.withdraw(int)) &amp;&amp; args(amount) &amp;&amp; target(acc);

	    

	    boolean around(int amount, Account acc) : 
	      callWithDraw(amount, acc) {
	    	long time= System.currentTimeMillis();
	       boolean ret=proceed(amount, acc);
	       System.out.println(System.currentTimeMillis()-time);
	        return ret;
	    }

	   
}
</programlisting></para>
		<para>EPAM: Reaktív programozás</para>
		<para><link
				xlink:href="https://github.com/Jatekos/Konyv_Prog_2/tree/master/reactiv-ReactorCore"
			/></para>
	</section>
	<section>
		<title>XP</title>
		<para>WebShop: 50xp</para>
		<para>UnitTest: 30xp</para>
		<para>XmlMapPloter: 10+5xp</para>
		<para>Kata: 30xp</para>
		<para>Össz.: 125xp</para>
	</section>    
  
  <section>
        <title>Java osztályok a Pi-ben</title>
        <para>
            Az előző feladat kódját fejleszd tovább: vizsgáld, hogy Vannak-e Java osztályok a Pi hexadecimális kifejtésében!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>     
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
